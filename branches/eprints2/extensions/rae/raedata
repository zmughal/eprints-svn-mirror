use EPrints::MetaField;
use EPrints::Session;
use EPrints::User;
use strict;

# Create session
my $session = new EPrints::Session;
exit( 0 ) unless( defined $session );
my $archive = $session->get_archive();

# Check user has appropriate privs
if( !$session->auth_check( "deposit" ) )
{
	$session->terminate();
	Apache::exit( 0 );
}
my $user = $session->current_user;

# Init RAE config/phrases
use RAELoader;
RAELoader::init_rae( $session );

# Show available roles
my $roles_part = $session->make_doc_fragment();
my $perms = $archive->get_conf("rae", "group_perms");


# Check selected role
my $role;
if (defined($session->param("role"))) {
	$role = EPrints::User->new($session, $session->param("role"));
	if (!defined($role)) {
		$role = $user;
	}
	if ($perms->{$user->get_id} ne $role->get_value("dept")) {
		# User cannot assume this role
		# TODO: error message
		$role = $user;
	}
} else {
	$role = $user;
}

if (defined( $perms->{$user->get_id} )) {
	my @roles;
	my $searchexp = new EPrints::SearchExpression(
		session => $session,
		custom_order => "name",
		dataset => $archive->get_dataset("user"),
	);
	$searchexp->add_field( $archive->get_dataset("user")->get_field("dept") , $perms->{$user->get_id} );
	$searchexp->perform_search;
	$searchexp->map( sub {
		my ( $session, $dataset, $item, $info ) = @_;
		push @roles, [ $item->get_id, EPrints::Utils::tree_to_utf8($item->render_description()) ];
	});
	my $form = $session->render_form();
	$form->appendChild($session->render_option_list(name => 'role', pairs => \@roles));
	$form->appendChild($session->render_action_buttons(submit => $session->phrase( "rae:change_role" )));
	
	if($role->get_id != $user->get_id)
	{
		$roles_part = $session->html_phrase( "rae:roles_behalf", 
			change_role => $form,
			current_user => $user->render_description(),
			current_role => $role->render_description(),		## new!!
		);
	}
	else
	{
		$roles_part = $session->html_phrase( "rae:roles", 
			change_role => $form,
			current_user => $user->render_description(),
		);
	}
}





# Get RAE data from DB
my %values;
my %behalf_ids;

my $sql = "SELECT field, value, chooserid FROM rae_data WHERE userid=" . $role->get_id;
my $sth = $session->get_db->prepare( $sql );
if( $session->get_db->execute( $sth, $sql ) )
{
	while( my @row = $sth->fetchrow )
	{
		
		$values{$row[0]} = $row[1];
		
		if(defined $row[2])
		{
			$behalf_ids{$row[0]} = $row[2];
		}
	}
	
}


# For each RAE field:
# - create metafield
# - check for value from input form
# - update DB if appropriate
# - build shortcuts
my @metafields;


my $shortcuts = $session->make_element( "ul" );
my $form = $session->render_form( "post" );
foreach my $field (@{$archive->get_conf("rae", "rae_fields")})
{
	my $metafield = EPrints::MetaField->new(
		# TODO: more flexible field definition in config
		type => "longtext",
		archive => $session->get_archive(),
		confid => "rae",
		name => $field,
	);
	# Use $session->param rather than $metafield->form_value
	# since we need to identify empty fields (e.g. if the user
	# clears a previous value from a field)
	# TODO: delete row from DB if field cleared?
	#my $val = $metafield->form_value( $session );
	
	my $val = $session->param( $field );

	if( defined $val )
	{
		my $qfield = $session->get_db->{dbh}->quote($field);
		my $qval = $session->get_db->{dbh}->quote($val);
		
		
		my $sql = undef;
		if( defined $values{$field} )
		{
			# quick check so that data gets replaced only if different from the one already stored
			# (so we don't lose the 'chooserid' parameter)
			
			if($session->get_db->{dbh}->quote($values{$field}) ne $qval)
			{
				$sql = "UPDATE rae_data SET value=$qval, chooserid=".$user->get_id." WHERE field=$qfield AND userid=" . $role->get_id;
			}
			
			
		} 
		elsif( $val ne "" ) 
		{
			$sql = "INSERT INTO rae_data VALUES (" . $role->get_id . ", $qfield, $qval,".$user->get_id.");";
		}
		if( defined $sql )
		{
			if ( !$session->get_db->do($sql) )
			{
				# TODO: better error handling?
				#$session->render_error("Error: $sql", $archive->get_conf( "perl_url" ) . "/users/rae/raeselect" );
			}
			else
			{
				#update hashes to incorporate the new data (the data which was not retrieved during the previous SELECT action):
				
				$values{$metafield->get_name} = $val;
				$behalf_ids{$metafield->get_name} = $user->get_id;
			}
		}
	} 
	push @metafields, $metafield;

	my $behalf = undef;
	
	if(defined $behalf_ids{$metafield->get_name} )
	{
		
		my $slave = EPrints::User->new($session, $behalf_ids{$metafield->get_name});

		$behalf = $session->html_phrase( "rae/data:text_entered" , user => $slave->render_description );
		
	}
	
	my $li = $session->make_element( "li" );
	$shortcuts->appendChild( $li );
	my $link = $session->render_link( "#" . $field );
	$link->appendChild( $session->make_text( EPrints::Utils::tree_to_utf8( $metafield->render_name( $session ) ) ) );

	
	$li->appendChild( $link );
	$li->appendChild( $behalf ) if(defined $behalf);
}


# Render input form
$form = $session->render_input_form(
	fields => \@metafields,
	values => \%values,
	show_names => 1,
	show_help => 1,
	buttons => { submit => $session->phrase( "rae/data:submit_button" ) },
);
$form->appendChild( $session->render_hidden_field( "role", $role->get_id ) );

$form->appendChild( $session->make_element( "br" ) );


#seb: forces the ChangeRole action when linking to RAESELECT... reason is that it forces RAESELECT to show the page at init (otherwise RAESELECT performs the search when loading)
my $link = $session->render_link( $archive->get_conf("perl_url") . "/users/rae/raeselect?role=" . $role->get_id."&_action_submit=Change+Role");

# Build & Send page
my $page = $session->html_phrase( "rae/data:page", 
	shortcuts => $shortcuts,
	form => $form,
	roles => $roles_part,
	select_link => $link,
);
my $title = $session->html_phrase( "rae/data:page_title", user => $role->render_description() );

$session->build_page( $title, $page );
$session->send_page();
$session->terminate();
exit;



