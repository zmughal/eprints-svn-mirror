#!/usr/bin/perl -w -I/opt/ep2stable/perl_lib

######################################################################
#
#  __COPYRIGHT__
#
# Copyright 2000-2008 University of Southampton. All Rights Reserved.
# 
#  __LICENSE__
#
######################################################################

=pod

=head1 NAME

B<upgrade> - Upgrade the stucture of the database to be compatable with
a newer version of eprints.

If upgrading requires more than one step then the system will perform
the upgrade step by step. If a step fails then you can continue from
where it left off.

=head1 SYNOPSIS

B<upgrade> I<repository_id> [B<options>]

=head1 DESCRIPTION

Some versions of eprints require modifications to be made to the database
tables used by earlier versions. 

Run this script on each repository after upgrading the eprints software. 

=head1 ARGUMENTS

=over 8

=item I<repository_id> 

The ID of the EPrint repository to effect.

=back

=head1 OPTIONS

=over 8

=item B<--help>

Print a brief help message and exit.

=item B<--man>

Print the full manual page and then exit.

=item B<--quiet>

This option doesn't do anything. You REALLY don't want to run this
script without knowing what's happening.

=item B<--verbose>

Explain in detail what is going on. 
May be repeated for greater effect.

=item B<--version>

Output version information and exit.

=back   

__GENERICPOD__

=cut



use EPrints;

use strict;
use Getopt::Long;
use Pod::Usage;

my $TARGET = $EPrints::Database::DBVersion;

my $verbose = 0;
my $version = 0;
my $quiet = 0;
my $help = 0;
my $man = 0;

GetOptions( 
	'help|?' => \$help,
	'man' => => \$man,
	'verbose+' => \$verbose,
	'version' => \$version,
	'silent' => \$quiet,
	'quiet' => \$quiet
) || pod2usage( 2 );
EPrints::Utils::cmd_version( "upgrade" ) if $version;
pod2usage( 1 ) if $help;
pod2usage( -exitstatus => 0, -verbose => 2 ) if $man;
pod2usage( 2 ) if( scalar @ARGV != 1 ); 

my $noise = 1;
$noise = 0 if( $quiet );
$noise = 1+$verbose if( $verbose );

# Set STDOUT to auto flush (without needing a \n)
$|=1;

my $session = new EPrints::Session( 1, $ARGV[0], $noise, 1 );
exit( 1 ) unless defined $session;

if( $noise>=1 ) { print "What is the current compatability of the DB?\n"; }
my $db = $session->get_database;
my $dbversion = $db->get_version();
if( !defined $dbversion )
{
	if( $noise>=1 ) { print "...No version flag. Must be pre 2.1\n"; }
	$dbversion = "2.0";
	if( $noise>=1 ) { print "Setting version to be 2.0\n"; }
	$db->create_version_table;
	$db->set_version( $dbversion );
}
else
{
	print "...DB Tables compatable with ".$dbversion."\n"; 
}	
if( $noise>=1 ) 
{ 
	print "Target compatibility is ".$TARGET."\n"; 
}

my $rootdbh = undef;

if( $dbversion eq "2.0" )
{
	my $sql;
	print <<END;
======================================================================
About to upgrade tables from 2.0 to 2.1

This will:

 * Erase the subscription tables. (If you have an active subscription
   service running on this repository then somethings wrong. Stop right
   now and figure it out.

 * Rebuild the subscription dataset tables how v2.1 wants them.

 * Set the subscription ID counter to zero.

 * Alter the columns "commentary", "replacedby" and "succeeds" in the
   tables "archive","deletion","inbox" and "buffer" from VARCHAR to
   INTEGER. These fields should have been INT's in the first place.

END
	
	my $sure = EPrints::Utils::get_input_confirm( "Are you sure you want to do this" );
	unless( $sure )
	{
		print "Aborting then.\n";
		$session->terminate();
		exit( 1 );
	}

	$rootdbh = &getrootdbh( $session ) unless( defined $rootdbh );

	my $ok = 1;
	$ok = $ok && defined $rootdbh;

	print "Dropping old subscription tables.\n";
	# drop all the old subscription tables
	my @tables = $db->get_tables;
	foreach my $table ( @tables )
	{
		if( $table =~ m/^subscription/ )
		{
			$sql = "DROP TABLE ".$table;
			$ok = $ok && $db->do( $sql );
		}
	}
	print "Making new subscription tables.\n";
	my $subs_ds = $session->get_repo->get_dataset( "subscription" );
	$ok = $ok && $db->create_dataset_tables( $subs_ds );
	print "Creating subscriptionid counter.\n";
	$sql = "DELETE FROM counters WHERE countername = 'subscriptionid'"; 
	$ok = $ok && $db->do( $sql );
	$sql = "INSERT INTO counters (countername,counter) VALUES ".
		"( 'subscriptionid' , 0 )";
	$ok = $ok && $db->do( $sql );
	foreach my $table_id ( "archive","inbox","buffer","deletion" )
	{
		$sql = "SELECT eprintid,succeeds,replacedby,commentary FROM ".
			$table_id;
		my $sth = $db->prepare( $sql );
		$ok = $ok && $db->execute( $sth, $sql );
		my $file = "/tmp/valuedump-".$session->get_repo->get_id."-".
			$table_id;
		open( VDUMP, ">$file" );
		print VDUMP "eprintid,succeeds,replacedby,commentary\n";
		my @row;
		while( @row = $sth->fetchrow_array )
		{
			foreach( @row ) 
			{
				$_ = 'NULL' if( !defined $_ );
			}
			print VDUMP join( ",", @row )."\n";
		}
		close VDUMP;
        	$sth->finish;
		print "Saved backup of affected fileds to $file\n";
		print "Altering columns of ".$table_id."\n";
		foreach my $col_id ( "succeeds","replacedby","commentary" )
		{
			$sql = "ALTER TABLE ".$table_id." MODIFY ".
				$col_id." INTEGER";
			$ok = $ok && $rootdbh->do( $sql );
		}
	}
	if( !$ok )
	{
		print "\nFailed.\n";
		print "Please investigate cause of errors then try again.\n";
	}
	else
	{
		print "\n2.0 -> 2.1 done!\n";
		$dbversion = "2.1";
		$db->set_version( $dbversion );
	}
}

if( $dbversion eq "2.1" )
{
	my $sql;
	print <<END;
======================================================================
About to upgrade tables from 2.1 to 2.2

This will:

 * in dataset "subscription"
    - add a new boolean field "mailempty"

 * in dataset "user"
    - remove the field "editorsubjects"
    - add the following fields:
       + editperms (search) 
       + mailempty (boolean) 
       + frequency (set) 

END
	
	my $sure = EPrints::Utils::get_input_confirm( "Are you sure you want to do this" );
	unless( $sure )
	{
		print "Aborting then.\n";
		$session->terminate();
		exit( 1 );
	}

	$rootdbh = &getrootdbh( $session ) unless( defined $rootdbh );

	my $ok = 1;
	$ok = $ok && defined $rootdbh;

	my @tables = $db->get_tables;

	# add "mailempty" to subscription

	$sql = "ALTER TABLE subscription ADD mailempty set('TRUE','FALSE') default NULL AFTER frequency";
	$ok = $ok && $rootdbh->do( $sql );
	foreach my $table ( @tables )
	{
		if( $table =~ m/^subscription__ordervalues_.*$/ )
		{
			$sql = "ALTER TABLE $table ADD mailempty text AFTER frequency",
			$ok = $ok && $rootdbh->do( $sql );
		}
	}


	# remove users "editorsubjects"

	$sql = "DROP TABLE users_editorsubjects";
	$ok = $ok && $rootdbh->do( $sql );
	foreach my $table ( @tables )
	{
		if( $table =~ m/^users__ordervalues_.*$/ )
		{
			$sql = "ALTER TABLE $table DROP editorsubjects";
			$ok = $ok && $rootdbh->do( $sql );
		}
	}


	# add "editperms","frequency" & "mailempty" to subscription

	$sql = "CREATE TABLE users_editperms ( userid INT NOT NULL, pos INT, editperms TEXT default NULL, KEY userid (userid), KEY pos (pos) )  ";
	$ok = $ok && $rootdbh->do( $sql );

	$sql = "ALTER TABLE users ADD frequency varchar(255) default NULL AFTER lang";
	$ok = $ok && $rootdbh->do( $sql );
	$sql = "ALTER TABLE users ADD mailempty set('TRUE','FALSE') default NULL AFTER frequency";
	$ok = $ok && $rootdbh->do( $sql );
	foreach my $table ( @tables )
	{
		if( $table =~ m/^users__ordervalues_.*$/ )
		{
			$sql = "ALTER TABLE $table ADD editperms TEXT AFTER lang";
			$ok = $ok && $rootdbh->do( $sql );
			$sql = "ALTER TABLE $table ADD frequency TEXT AFTER editperms";
			$ok = $ok && $rootdbh->do( $sql );
			$sql = "ALTER TABLE $table ADD mailempty TEXT AFTER frequency";
			$ok = $ok && $rootdbh->do( $sql );
		}
	}


#	# add "hash" to document
#
#	$sql = "ALTER TABLE document ADD hash TEXT default NULL AFTER main";
#	$ok = $ok && $rootdbh->do( $sql );
#	foreach my $table ( @tables )
#	{
#		if( $table =~ m/^document__ordervalues_.*$/ )
#		{
#			$sql = "ALTER TABLE $table ADD hash text AFTER main",
#			$ok = $ok && $rootdbh->do( $sql );
#		}
#	}


	if( !$ok )
	{
		print "\nFailed.\n";
		print "Please investigate cause of errors then try again.\n";
	}
	else
	{
		print "\n2.1 -> 2.2 done!\n";
		$dbversion = "2.2";
		$db->set_version( $dbversion );
	}
}

if( $dbversion eq "2.2" )
{
	my $sql;
	print <<END;
======================================================================
About to upgrade tables from 2.2 to 2.3

This will:

 * Remove the no longer used "rindex" tables. 

 * Grant ALTER permissions to the database user. 

END
	
	my $sure = EPrints::Utils::get_input_confirm( "Are you sure you want to do this" );
	unless( $sure )
	{
		print "Aborting then.\n";
		$session->terminate();
		exit( 1 );
	}

	$rootdbh = &getrootdbh( $session ) unless( defined $rootdbh );

	my $ok = 1;
	$ok = $ok && defined $rootdbh;

	my @tables = $db->get_tables;

	# remove rindex tables

	foreach my $table ( @tables )
	{
		if( $table =~ m/__rindex$/ )
		{
			$sql = "DROP TABLE $table";
			$ok = $ok && $rootdbh->do( $sql );
		}
	}

	# Grant ALTER

	my $dbname = $session->get_repo->get_conf( "dbname" );
	my $dbuser = $session->get_repo->get_conf( "dbuser" );
	my $SQL = 'GRANT ALTER ON '.$dbname.'.* TO '.$dbuser.'@localhost';
	$rootdbh->do( $SQL );

	if( !$ok )
	{
		print "\nFailed.\n";
		print "Please investigate cause of errors then try again.\n";
	}
	else
	{
		print "\n2.2 -> 2.3 done!\n";
		$dbversion = "2.3";
		$db->set_version( $dbversion );
	}
}





if( $dbversion eq "2.3" )
{
	my $sql;
	print <<END;
======================================================================
About to upgrade tables from 2.3 to 2.3.99.3

This will:

 * Change datestamp to a datetime (was a date)
 * Add a new datetime called "first live" with
    the default value taken from datestamp.
 * Rename all the users_ tables to user_
 * Erase the old index tables and create new
    ones.
 * Add a new table: indexqueue
 * Insert a new column next to every date field
    to store the resolution.
 * Insert a "rev_number" field into all dataobj's
    which will be used to store what revision the
    record is.
 * Add a field to "document" called "license".
 * Add a field to the dataset "eprint" called "date_embargo".
 * Add two permissions tables: user_permisssions and user_groups

END
	
	my $sure = EPrints::Utils::get_input_confirm( "Are you sure you want to do this" );
	unless( $sure )
	{
		print "Aborting then.\n";
		$session->terminate();
		exit( 1 );
	}

	my $ok = 1;

	my @tables = $db->get_tables;
	# change the sql tables for the "user" dstaset to be "user..." rather
	# than users...
	foreach my $table ( @tables )
	{
		next unless( $table =~ m/^users(.*)/ );
		$sql = "RENAME TABLE users$1 TO user$1";
		$db->do( $sql );
	}


	# Merge inbox,archive,deletion and buffer into one place.



	# reread the tables as they've changed
	@tables = $db->get_tables;

	# rev_number to all dataobj's
	foreach my $datasetid ( qw/ archive buffer inbox deletion user document subscription subject / )
	{
		my $dataset = $session->get_repo->get_dataset( $datasetid );
		my $pkey = $dataset->get_key_field->get_sql_name;
		my $tablename = $dataset->get_sql_table_name;

		$sql = "ALTER TABLE $tablename ADD rev_number INTEGER DEFAULT 1 AFTER $pkey";
		$db->do( $sql );

		# add the ordervalues for rev_number
		foreach my $table ( @tables )
		{
			if( $table =~ m/^($tablename)__ordervalues_.*$/ )
			{
				$sql = "ALTER TABLE $table ADD rev_number text AFTER $pkey",
				$db->do( $sql );
			}
		}

	}

do this for every eprint?

#	my $rev_file = $dir."/".$eprint->get_value("rev_number").".xml";
#	unless( open( REVFILE, ">$rev_file" ) )
#	{
#		$eprint->{session}->get_repo->log( "Error writing file: $!" );
#		return;
#	}
#	print REVFILE '<?xml version="1.0" encoding="utf-8" ?>'."\n";
#	print REVFILE $eprint->export( "XML", fh=>*REVFILE );
#	close REVFILE;

Text not integer?

historyid and accessid

	# add "license" to the document dataobject.
	$sql = "ALTER TABLE document ADD license VARCHAR(255) DEFAULT NULL AFTER security";
	$db->do( $sql );

	# add the ordervalues for license
	foreach my $table ( @tables )
	{
		if( $table =~ m/^document__ordervalues_.*$/ )
		{
			$sql = "ALTER TABLE $table ADD license text AFTER security",
			$db->do( $sql );
		}
	}




	# add "date_embargo" to the eprint dataset
	foreach my $table_id ( "inbox","buffer","archive","deletion" )
	{
		$sql = "ALTER TABLE $table_id ADD date_embargo DATE AFTER replacedby";
		$db->do( $sql );
	}
	
	# add the ordervalues for date_embargo
	foreach my $table ( @tables )
	{
		if( $table =~ m/^(archive|buffer|inbox|deletion)__ordervalues_.*$/ )
		{
			$sql = "ALTER TABLE $table ADD date_embargo text AFTER replacedby",
			$db->do( $sql );
		}
	}

	# add "contact_email" to the eprint dataset

	foreach my $table_id ( "inbox","buffer","archive","deletion" )
	{
		$sql = "ALTER TABLE $table_id ADD contact_email VARCHAR(255) AFTER date_embargo";
		$db->do( $sql );
	}
	
	# add the ordervalues for contact_email
	foreach my $table ( @tables )
	{
		if( $table =~ m/^(archive|buffer|inbox|deletion)__ordervalues_.*$/ )
		{
			$sql = "ALTER TABLE $table ADD contact_email text AFTER date_embargo",
			$db->do( $sql );
		}
	}

	# add user_permissions and user_groups
	$sql = "CREATE TABLE user_permissions (role char(64) not null, privilege char(64) not null, net_from long, net_to long, PRIMARY KEY(role,privilege), UNIQUE(privilege,role))";
	$db->do( $sql );
	$sql = "CREATE TABLE user_groups (user char(64) not null, role char(64) not null, PRIMARY KEY(user,role))";
	$db->do( $sql );

	# add the default privileges
	$sql = <<EOS;
INSERT IGNORE INTO user_permissions VALUES
	('\@subscription','EDIT_USER_SUBSCRIPTIONS',null,null),
	('\@set_password','EDIT_USER_PASSWORD',null,null),
	('\@deposit','CREATE_EPRINT_INBOX',null,null),
	('\@deposit','DERIVE_EPRINT_CLONE',null,null),
	('\@deposit','DERIVE_EPRINT_VERSION',null,null),
	('\@deposit','EDIT_EPRINT_INBOX',null,null),
	('\@deposit','MOVE_EPRINT_INBOX_BUFFER',null,null),
	('\@deposit','REQUEST_EPRINT_DELETION',null,null),
	('\@change_email','EDIT_USER_EMAIL',null,null),
	('\@change_user','LOGIN_USER',null,null),
	('\@change_user','LOGOUT_USER',null,null),
	('\@change_user','EDIT_USER',null,null),
	('\@editor','DELETE_EPRINT_INBOX',null,null),
	('\@editor','DELETE_EPRINT_BUFFER',null,null),
	('\@editor','DELETE_EPRINT_ARCHIVE',null,null),
	('\@editor','DELETE_EPRINT_DELETION',null,null),
	('\@editor','EDIT_EPRINT_INBOX',null,null),
	('\@editor','EDIT_EPRINT_BUFFER',null,null),
	('\@editor','EDIT_EPRINT_ARCHIVE',null,null),
	('\@editor','EDIT_EPRINT_DELETION',null,null),
	('\@editor','EDIT_EPRINT_INBOX_ALL',null,null),
	('\@editor','EDIT_EPRINT_BUFFER_ALL',null,null),
	('\@editor','EDIT_EPRINT_ARCHIVE_ALL',null,null),
	('\@editor','EDIT_EPRINT_DELETION_ALL',null,null),
	('\@editor','MOVE_EPRINT_INBOX_BUFFER',null,null),
	('\@editor','MOVE_EPRINT_BUFFER_INBOX',null,null),
	('\@editor','MOVE_EPRINT_BUFFER_ARCHIVE',null,null),
	('\@editor','MOVE_EPRINT_ARCHIVE_BUFFER',null,null),
	('\@editor','MOVE_EPRINT_ARCHIVE_DELETION',null,null),
	('\@editor','MOVE_EPRINT_DELETION_ARCHIVE',null,null),
	('\@staff_view','VIEW_EPRINT_ALL',null,null),
	('\@staff_view','VIEW_EPRINT_FILES_ALL',null,null),
	('\@edit_subject','EDIT_ARCHIVE_SUBJECTS',null,null),
	('\@edit_user','DELETE_USER',null,null),
	('\@edit_user','EDIT_USER_FULL',null,null),
	('eprint.owner','VIEW_EPRINT_INBOX',null,null),
	('eprint.owner','VIEW_EPRINT_BUFFER',null,null),
	('eprint.owner','VIEW_EPRINT_ARCHIVE',null,null),
	('eprint.owner','VIEW_EPRINT_DELETION',null,null),
	('eprint.owner','EDIT_EPRINT_INBOX',null,null),
	('eprint.owner','MOVE_EPRINT_INBOX_BUFFER',null,null),
	('eprint.owner','REQUEST_EPRINT_DELETION',null,null),
	('user.owner','EDIT_USER_SUBSCRIPTIONS',null,null),
	('user.owner','VIEW_USER',null,null),
	('user.owner','VIEW_USER_CONTRIBUTIONS',null,null),
	('user.owner','LOGOUT_USER',null,null),
	('anonymous','LOGIN_USER',null,null),
	('anonymous','REGISTER_USER',null,null),
	('anonymous','VALIDATE_USER',null,null),
	('anonymous','VIEW_PAGES_BROWSE',null,null),
	('anonymous','VIEW_PAGES_STATIC',null,null),
	('usertype.admin','EDIT_ARCHIVE_PRIVILEGES',null,null);
EOS
	$dbh->do( $sql );
	
	# convert most system DATE fields into DATETIME fields.

	$sql = "ALTER TABLE user MODIFY joined DATETIME";
	$db->do( $sql );


	foreach my $table_id ( "inbox","buffer","archive","deletion" )
	{
		$sql = "ALTER TABLE $table_id MODIFY datestamp DATETIME";
		$db->do( $sql );
		$sql = "ALTER TABLE $table_id ADD lastmod DATETIME AFTER datestamp";
		$db->do( $sql );
		$sql = "UPDATE $table_id SET lastmod = datestamp";
		$db->do( $sql );
		$sql = "ALTER TABLE $table_id ADD status_changed DATETIME AFTER lastmod";
		$db->do( $sql );
		$sql = "UPDATE $table_id SET status_changed = datestamp";
		$db->do( $sql );
	}

	# remove the datestamp for items which are not yet live
	foreach my $table_id ( "inbox","buffer" )
	{
		$sql = "UPDATE $table_id SET datestamp = NULL";
		$db->do( $sql );
	}

	# re read the tables.	
	@tables = $db->get_tables;

	# add the ordervalues for lastmod and status_changed
	foreach my $table ( @tables )
	{
		if( $table =~ m/^(archive|buffer|inbox|deletion)__ordervalues_.*$/ )
		{
			$sql = "ALTER TABLE $table ADD lastmod text AFTER datestamp",
			$db->do( $sql );
			$sql = "ALTER TABLE $table ADD status_changed text AFTER lastmod",
			$db->do( $sql );
		}
	}

	# add a resolution column to every date or datestamp field

	my @datefields = ();
	foreach my $table ( @tables )
	{
		next unless( $table =~ m/^(archive|buffer|inbox|deletion|user|document|subscription|subject)/ );
		
		$sql = "DESCRIBE $table";
		my $sth = $db->prepare( $sql );
		$ok = $ok && $db->execute( $sth, $sql );
		while( my @row = $sth->fetchrow_array )
		{
			next unless $row[1] eq "date" || $row[1] eq "datetime";
			push @datefields, [ $table, $row[0] ];
		}
        	$sth->finish;
	}
	foreach my $pair ( @datefields )
	{
		my( $table, $col ) = @{$pair};
		my $rescol = $col."_resolution";
		print $pair->[0]." .. ".$pair->[1]."\n";
		$sql = "ALTER TABLE $table ADD $rescol INTEGER AFTER $col";
		$db->do( $sql );
		$sql = "UPDATE $table SET $rescol=3";
		$db->do( $sql );
		$sql = "UPDATE $table SET $rescol=2 where day($col)=0";
		$db->do( $sql );
		$sql = "UPDATE $table SET $rescol=1 where month($col)=0";
		$db->do( $sql );
	}

	# remove old index index_grep rindex and temporary index tables
	foreach my $table ( @tables )
	{
		next unless $table =~ m/__index(_grep)?(_tmp)?$|__rindex$/;
		$sql = "DROP TABLE $table";
		$db->do( $sql );
		
		print "REMOVING: $table\n";
	}
#userid, eprintid,docid,subid,subjectid
	$db->_create_indexqueue_table;
	foreach my $datasetid ( qw/ archive buffer inbox deletion user document subscription subject / )
	{
		print "Making new index tables: $datasetid\n";
		my $dataset = $session->get_repo->get_dataset( $datasetid );
		$db->create_dataset_index_tables( $dataset );

		# queue all items for indexing
		$dataset->map( $session, sub {
			my( $session, $dataset, $item ) = @_;
		
			foreach my $field ( $dataset->get_fields() )
			{
				next unless( $field->get_property( "text_index" ) );
				# skip fields we've not added yet.
				next if( $field->get_name eq "license" && $datasetid eq "document" );
				next if( $field->get_name eq "rev_number" );
		
				$session->get_database->index_queue( 
					$dataset->id,
					$item->get_id,
					$field->get_name );
			}	
			if( $dataset->confid eq "eprint" )
			{
				$session->get_database->index_queue( 
					$dataset->id,
					$item->get_id,
					$EPrints::Utils::FULLTEXT );
			}

		} );

	}

	if( !$ok )
	{
		print "\nFailed.\n";
		print "Please investigate cause of errors then try again.\n";
	}
	else
	{
		print "\n2.3 -> 2.3.99.3 done!\n";
		$dbversion = "2.3.99.3";
		$db->set_version( $dbversion );
	}
}

if( $dbversion eq "2.3.99.2" )
{
	my $ok = $db->create_dataset_tables( $session->get_repo->get_dataset( 'history' ) );

	$sql = "INSERT INTO ".$counter_ds->get_sql_table_name()." ".
		"VALUES (\"$counter\", 0);";

	$ok &= $self->do( $sql );
		
	if( !$ok )
	{
		print "\nFailed.\n";
		print "Please investigate cause of errors then try again.\n";
	}
	else
	{
		print "\n2.3.99.2 -> 2.3.99.3 done!\n";
		$dbversion = "2.3.99.3";
		$db->set_version( $dbversion );
	}
}





if( $TARGET eq $dbversion)
{
	if( $noise>=1 )
	{
		print "Target compatability reached.\n";
	}
}
else
{
	print <<END;
**********************************************************************
WARNING: Target compatibility NOT reached. That probably means 
something bad happend.
**********************************************************************
END
}

if( defined $rootdbh )
{
	$rootdbh->disconnect;
}

$session->terminate();
exit;


sub getrootdbh
{
	my( $session ) = @_;
	print <<END;

We will need to do some stuff to the database as root. Please enter
the MySQL root password. (Warning: It will not be ****'d out when you 
type it).

END
	my $mysqlrootpass = EPrints::Utils::get_input( '^.*$', "MySQL Root Password" );

	print "Connecting to the database [as root]\n";
        my $dbh = DBI->connect(
                EPrints::Database::build_connection_string(
                        dbname=>$session->get_repo->get_conf("dbname"),
                        dbsock=>$session->get_repo->get_conf("dbsock"),
                        dbport=>$session->get_repo->get_conf("dbport"),
                        dbhost=>$session->get_repo->get_conf("dbhost") ),
                "root",
                $mysqlrootpass );

	return $dbh;
}
