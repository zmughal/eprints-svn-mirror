#!/usr/bin/perl -w -I/opt/eprints3/perl_lib

######################################################################
#
#  __COPYRIGHT__
#
# Copyright 2000-2008 University of Southampton. All Rights Reserved.
# 
#  __LICENSE__
#
######################################################################

=pod

=head1 NAME

B<epadmin> - EPrints repository admin tool

=head1 SYNOPSIS

B<epadmin> I<command> I<repository_id> [B<options>]

Where I<command> is one of:

=over 4

=item cleanup_cachemaps

=item config_core

=item config_db

=item create

=item create_db

=item create_tables

=item create_user

=item erase_data

=item erase_eprints

=item erase_fulltext_index

=item help

=item profile

=item recommit

=item reorder

=item redo_thumbnails

=item refresh_abstracts

=item refresh_views

=item rehash

=item reindex

=item reload

=item reload_metafields

=item schema

=item test

=item unit_tests

=item update_database_structure

=item upgrade

=back

Type I<epadmin help> for further help.

=head1 ARGUMENTS

=over 8

=item B<epadmin> create

START HERE! This option will walk you through the tasks needed to create your repository.

=item B<epadmin> test I<repository_id>

A null operation which just checks your configuration files are OK and that you can connect to the database. If no I<repository_id> is specified loads each repository in turn.

=item B<epadmin> cleanup_cachemaps I<repository_id>

Drop any orphaned cache tables.

=item B<epadmin> config_core I<repository_id>

Set hostname, contact email and repository name. 

=item B<epadmin> config_db I<repository_id>

Set database connection properties and, optionally, to create database and database user.

=item B<epadmin> create_db I<repository_id>

Create a database and database user with the current settings.

=item B<epadmin> create_tables I<repository_id>

Create the database tables.

=item B<epadmin> create_user I<repository_id>

Create a new user. You need to do this to create your first admin account.

=item B<epadmin> schema I<repository_id>

Use this to produce a schema for the EP3 XML read/written by your repository. 

=item B<epadmin> erase_fulltext_index I<repository_id>

This erases all the .words and .indexcodes cache files from your repository, forcing the indexer to rerun the tools used to extract full text from your documents.

This is useful if you only setup the fulltext indexing after your repository is already live, or if you discover there has been a problem.

=item B<epadmin> recommit I<repository_id> I<dataset_id>

Recommit all the records in the given dataset. What this does is cause the automatic values to be re-calculated.

=item B<epadmin> reindex I<repository_id> I<dataset_id>

Schedule the dataset for reindexing. The indexer will do the actual indexing and it may take some time. This only schedules the reindexing.

=item B<epadmin> reorder I<repository_id> I<dataset_id>

Regenerate the order values for the dataset.

=item B<epadmin> rehash I<repository_id> [I<document_id>]

Recalculate the hashes of the files in this document and write it to a probity log file. If a document id is given then just generate the hash for that document.

=item B<epadmin> reload I<repository_id>

Cause the web server to reload the repository configuration.

=item B<epadmin> refresh_views I<repository_id>

Tell the webserver that all views pages must be regenerated. The webserver will update them next time they are requested. Also causes config to be reloaded.

=item B<epadmin> refresh_abstracts I<repository_id>

Tell the webserver that all abstract summary pages must be regenerated. The webserver will update them next , but won't update them again unless something on the EPrint changes or you re-run refresh abstracts. Also causes config to be reloaded.

=item B<epadmin> redo_thumbnails I<repository_id> [I<eprintid], ...]

Regenerate all the thumbnail and image-preview files and any other things which
are triggered if the document file changed. Optionally supply a list of eprint
ids to re-generate thumbnails for.

=item B<epadmin> reload_metafields I<repository_id>

Reload the metafields dataset, based on the current configuration.

=item B<epadmin> erase_data I<repository_id>

Erases and recreates the database. Removes all documents and files. Does not touch the configuration files.

=item B<epadmin> erase_eprints I<repository_id>

Erases all the documents and eprints (including their files). Recreates the eprint and document tables. Leaves configuration files and the users and subjects tables alone.

=item B<epadmin> unit_tests

Run unit tests, printing the results to STDOUT. If everything passed will exit
with a return code of 0.

=item B<epadmin> profile I<test>

Run a performance profile of I<test> using L<Devel::NYTProf>.

=item B<epadmin> upgrade I<repository_id>

After upgrading EPrints, use this to update the database tables. It will advise any other tasks that are required.

=item B<epadmin> --help

=back

=head1 OPTIONS

=over 8

=item B<--help>

Print a brief help message and exit.

=item B<--man>

Print the full manual page and then exit.

=item B<--quiet>

This option does not do anything.

=item B<--verbose>

Explain in detail what is going on. May be repeated for greater effect.

=item B<--force>

Be more forceful (don't ask for confirmation).

=item B<--version>

Output version information and exit.

=back   

__GENERICPOD__

=cut

#cjg Does not use noise levels


use EPrints;

use Sys::Hostname;
use DBI;
use Data::Dumper;

use strict;
use Getopt::Long;
use Pod::Usage;

my $verbose = 0;
my $quiet = 0;
my $help = 0;
my $man = 0;
my $version = 0;
my $force = 0;

Getopt::Long::Configure("permute");

GetOptions( 
	'help|?' => \$help,
	'man' => \$man,
	'version' => \$version,
	'verbose+' => \$verbose,
	'silent' => \$quiet,
	'quiet' => \$quiet,
	'force' => \$force,
) || pod2usage( 2 );
EPrints::Utils::cmd_version( "epadmin" ) if $version;
pod2usage( 1 ) if $help;
pod2usage( -exitstatus => 0, -verbose => 2 ) if $man;
pod2usage( 2 ) if( scalar @ARGV == 0 ); 

# Set STDOUT to auto flush (without needing a \n)
$|=1;

my $noise = 1;
$noise = 0 if( $quiet );
$noise = 1+$verbose if( $verbose );

my $REGEXP_HOSTNAME_MIDDLE = '[a-z0-9-]+(\.[a-z0-9-]+)*';
my $REGEXP_HOSTNAME = '^'.$REGEXP_HOSTNAME_MIDDLE.'$';
my $REGEXP_EMAIL = '^[^@]+@'.$REGEXP_HOSTNAME_MIDDLE.'$';
my $REGEXP_HOSTNAME_FULL = '^[a-z0-9-]+(\.[a-z0-9-]+)*$';
my $REGEXP_VARNAME = '^[a-zA-Z][_A-Za-z0-9]*$';
my $REGEXP_NUMBER = '^[0-9]+$';
my $REGEXP_YESNO = '^(yes|no)$';
my $REGEXP_ANY = '^.*$';
my @PASSWORD_CHARS = ( 'a'..'z','A'..'Z','0'..'9' );

my $action = $ARGV[0];
if( $action eq "create" ) { create(); }
elsif( $action eq "test" ) { test( $ARGV[1] ); }
elsif( $action eq "unit_tests" ) { unit_tests( @ARGV[1..$#ARGV] ); }
elsif( $action eq "profile" ) { profile( $ARGV[1] ); }
else
{
	my $repoid = $ARGV[1];
	pod2usage(1) unless defined $repoid;
	if( $action eq "cleanup_cachemaps" ) { cleanup_cachemaps( $repoid ); }
	elsif( $action eq "config_core" ) { config_core( $repoid ); }
	elsif( $action eq "config_db" ) { config_db( $repoid ); }
	elsif( $action eq "create_db" ) { create_db( $repoid ); }
	elsif( $action eq "create_user" ) { create_user( $repoid ); }
	elsif( $action eq "create_tables" ) { create_tables( $repoid ); }
	elsif( $action eq "erase_data" ) { erase_data( $repoid ); }
	elsif( $action eq "erase_eprints" ) { erase_eprints( $repoid ); }
	elsif( $action eq "erase_fulltext_index" ) { erase_fulltext_index( $repoid ); }
	elsif( $action eq "reload" ) { reload( $repoid ); }
	elsif( $action eq "reload_metafields" ) { reload_metafields( $repoid ); }
	elsif( $action eq "refresh_abstracts" ) { refresh_abstracts( $repoid ); }
	elsif( $action eq "refresh_views" ) { refresh_views( $repoid ); }
	elsif( $action eq "redo_thumbnails" ) { redo_thumbnails( $repoid, @ARGV[2..$#ARGV] ); }
	elsif( $action eq "upgrade" ) { upgrade( $repoid ); }
	elsif( $action eq "schema" ) { schema( $repoid ); }
	elsif( $action eq "update_database_structure" ) { update_database_structure( $repoid ); }
	elsif( $action eq "recommit" ) 
	{
		my $datasetid = $ARGV[2];
		pod2usage(1) unless defined $datasetid;
		recommit( $repoid, $datasetid ); 
	}
	elsif( $action eq "reindex" ) 
	{
		my $datasetid = $ARGV[2];
		pod2usage(1) unless defined $datasetid;
		reindex( $repoid, $datasetid ); 
	}
	elsif( $action eq "reorder" )
	{
		my $datasetid = $ARGV[2];
		pod2usage(1) unless defined $datasetid;
		reorder( $repoid, $datasetid ); 
	}
	elsif( $action eq "rehash" ) { rehash( $repoid ); }
	else { pod2usage( 1 ); }
}


exit;



sub create
{
	pod2usage( 2 ) if( scalar @ARGV != 1 ); 

	print <<END;

Create an EPrint Repository

Please select an ID for the repository, which will be used to create a directory
and identify the repository. Lower case letters and numbers, may not start with
a number. examples: "lemurprints" or "test3"

END
	if( scalar EPrints::Config::get_repository_ids() )
	{
		print "Existing repositories:\n";
		print join( ", ", EPrints::Config::get_repository_ids() )."\n\n";
	}

	my $repoid = EPrints::Utils::get_input( $REGEXP_VARNAME, 'Archive ID' );

	my $repodir = EPrints::Config::get( "base_path" )."/archives/".$repoid;

	my $loaded_config = EPrints::Config::get_repository_config( $repoid );		
	my $exists = ( defined $loaded_config );

	if( $exists )
	{
		print "A repository with that ID already exist.\n";
		exit;	
	}

	unless( -e $repodir )
	{
		print "We need to create $repodir, doing it now...\n";
		unless( EPrints::Platform::mkdir( $repodir ) )
		{
			print "Problem creating directory\n\n";
			exit;
		}
	}
	unless( -d $repodir )
	{	
		print "$repodir MUST be a directory.\n\n";
	}

	my $username = EPrints::Config::get( "user" );
	my $group = EPrints::Config::get( "group" );
	print "Getting uid and gid information for $username\n";
	my $uid = EPrints::Platform::getpwnam( $username );
	my $gid = EPrints::Platform::getgrnam( $group );
	print "UID: $uid\n";
	print "GID: $gid\n";
	print "\nCreating initial files:\n";
	&install( 
		EPrints::Config::get( "base_path" )."/lib/defaultcfg",
		eval($EPrints::SystemSettings::conf->{"file_perms"}),
		$uid,
		$gid,
		$repodir."/cfg",
		$repoid );

	foreach( "var", "html", "documents", "documents/disk0" )
	{
		my $dir = $repodir."/".$_;
		EPrints::Platform::mkdir( $dir );
		EPrints::Platform::chown( $uid, $gid, $dir );
	}
	print <<END;

Ok. I've created the initial config files and directory structure. 
I've also created a "disk0" directory under documents/ if you want
your full texts to be stored on a different partition then remove 
the disk0, and create a symbolic link to the directory you wish to
store the full texts in. Additional links may be placed here to be
used when the first is full.

END
	print "\n";
	my $config_core = EPrints::Utils::get_input( $REGEXP_YESNO, "Configure vital settings?", "yes" );
	if( $config_core eq "yes" )
	{
		config_core( $repoid );	
	}
	else
	{
		print "OK, but you'll need to edit 10_core.pl by hand in that case.\n";
	}

	print "\n";
	my $config_db = EPrints::Utils::get_input( $REGEXP_YESNO, "Configure database?", "yes" );
	if( $config_db eq "yes" )
	{
		config_db( $repoid );	
	}
	else
	{
		print "OK, but you'll need to edit database.pl by hand in that case, and make sure the database exists.\n";
	}


	print "\n";
	my $create_user = EPrints::Utils::get_input( $REGEXP_YESNO, "Create an initial user?", "yes" );
	if( $create_user eq "yes" )
	{
		create_user( $repoid );	
	}
	else
	{
		print "OK, but you will not be able to log into the website. You can always run 'epadmin create_user $repoid' later.\n"
	}
# cjg: Register with website!

	my $ok;
	$ok = EPrints::Utils::get_input( $REGEXP_YESNO, "Do you want to build the static web pages?", "yes" );
	if( $ok eq "yes" )
	{
		run_script( $repoid, "generate_static", "--verbose", $repoid );	
	}

	$ok = EPrints::Utils::get_input( $REGEXP_YESNO, "Do you want to import the LOC subjects?", "yes" );
	if( $ok eq "yes" )
	{
		run_script( $repoid, "import_subjects", "--verbose", "--force", $repoid );	
	}

	$ok = EPrints::Utils::get_input( $REGEXP_YESNO, "Do you want to update the apache config files? (you still need to add the 'Include' line)", "yes" );
	if( $ok eq "yes" )
	{
		run_script( $repoid, "generate_apacheconf", "--verbose" );
	}

	my $base_path = EPrints::Config::get( "base_path" );
print <<END;

--------------------------------------------------------------------------
That seemed to more or less work...
--------------------------------------------------------------------------

Now make any required changes to the cfg files. 

Note that changing the metadata configuration may require the database
tables to be regenerated. epadmin erase_data will regenerate the 
eprints and documents tables only. erase_data will regenerate everything.
(nb. these also do erase the contents of the tables, and any uploaded 
files).

Make sure that your main apache config file contains the line:

 Include $base_path/cfg/apache.conf

Then stop and start your webserver:
Often:
 /etc/rc.d/init.d/httpd stop
 /etc/rc.d/init.d/httpd start
(or maybe /usr/local/apache/bin/apachectl stop & start)

And then try connecting to your repository.
--------------------------------------------------------------------------

Don't forget to register your repository at http://roar.eprints.org/

END

exit;

}

	
# don't be fooled. This isn't the same as the install() in
# eprints-install
sub install
{
	my($dir, $perms, $user, $group, $dest, $repoid) = @_;

	print "Installing: $dest\n";
	opendir(INDIR, $dir) or die("Unable to install directory: $dir");
	my @dirs = ();
	my @files = ();
	EPrints::Platform::mkdir( $dest );
	EPrints::Platform::chown($user, $group, $dest);
	while(my $item = readdir(INDIR))
	{
		next if $item=~m/^\./;
		if (-d "$dir/$item") { push(@dirs, $item); }
		else { push(@files, $item); }
	}
	closedir(INDIR);
	foreach my $filename (@files)
	{
		if( $filename eq "Config.pm" )
		{
			open(my $i_fh, "<", "$dir/$filename");
			open(my $o_fh, ">", "$dest/$filename")
				or die "Can't write to $dest/$filename";
			while(defined($_ = <$i_fh>))
			{
				if( /^package/ )
				{
					# Change the package name to the local repository ($/ = line seperator)
					$_ = "package EPrints::Config::$repoid;$/";
				}
				print $o_fh $_;
			}
			close($i_fh);
			close($o_fh);
		}
		else
		{
			EPrints::Utils::copy("$dir/$filename", "$dest/$filename");
		}
		EPrints::Platform::chmod($perms, "$dest/$filename");
		EPrints::Platform::chown($user, $group, "$dest/$filename");
	}
	foreach(@dirs)
	{
		install("$dir/".$_, $perms, $user, $group, "$dest/$_", $repoid );
	}
}

sub run_script
{
	my( $repoid, $script, @opts ) = @_;

	my $repo = EPrints::Repository->new( $repoid );
	my $bin = $repo->get_conf( "bin_path" );

	system( "$bin/$script", @opts );
}

sub cleanup_cachemaps
{
	my( $repoid ) = @_;

	my $session = EPrints::Session->new( 1 , $repoid, $noise );
	if( !defined $session )
	{
		print STDERR "Failed to load repository: $repoid\n";
		exit 1;
	}

	my $c = $session->get_database->drop_orphan_cache_tables;

	if( $c == 0 )
	{
		$session->get_repository->log( "No orphaned cache tables found" );
	}

	$session->terminate;
}

sub config_core
{
	my( $repoid ) = @_;

	print "Core configuration for $repoid\n\n";

	my %config = ();

	$config{port} = 80;
	$config{host} = undef;
	$config{urlpath} = '/';
	$config{archiveroot} = "archives/".$repoid;
	$config{configmodule} = "cfg/Config.pm";
	$config{aliases} = [];
	$config{securehost} = undef;
	$config{securepath} = undef;

	$config{adminemail} = undef;

	$config{archive_name} = "Test Repository";

print <<END;

Please enter the fully qualified hostname of the repository. 

For a production system we recommend against using the real hostname of the 
machine. 

Example: $repoid.footle.ac.uk

END

	$config{host} = EPrints::Utils::get_input( $REGEXP_HOSTNAME_FULL, 'Hostname', $config{host} );

print <<END;

Please enter the port of the webserver. This is probably 80, but you may wish 
to run apache on a different port if you are experimenting.

END

	$config{port} = EPrints::Utils::get_input( $REGEXP_NUMBER, 'Webserver Port', $config{port} );


	# calculate example aliases
	my $realhostname = hostname();
	if( $realhostname !~ m/\./ )
	{
		# No dots in the actual hostname! Lets try and got the
		# domain from resolv.conf
		my $domain = "";
		if( open( RESOLV, "/etc/resolv.conf" ) && 0)
		{
			while( <RESOLV> )
			{
				if( m/^search\s+([^\s]+)/ )
				{
					$domain = $1;	
					last;
				}
			}
			close RESOLV;
		}
		$domain = "mydomain.com" if( $domain eq "" );
		$realhostname.=".".$domain;
	}
	my @example_aliases = ();
	push @example_aliases,$realhostname;
	
	$realhostname=~m/^(([^\.]*)\.[^\.]*)(\.|$)?/;
	push @example_aliases,$1 if( $3 eq ".");
	push @example_aliases,$2;
	
	$config{host}=~m/^(([^\.]*)\.[^\.]*)(\.|$)?/;
	push @example_aliases,$1 if( $3 eq "." );
	push @example_aliases,$2;
	print <<END;
	
Please enter all the aliases which could reach the repository, and indicate if 
you would like EPrints to write a Redirect Rule to redirect requests to this
alias to the correct URL.
END
	if( scalar @{$config{aliases}}==0 )
	{
		print "Some suggestions:\n";
		foreach( @example_aliases )
		{
			print $_."\n";
		}
	}
	print <<END;
	
Enter a single hash (#) when you're done.

END

	my @aliases = @{$config{aliases}};
	$config{aliases} = [];

	for(;;)
	{
		my $default = shift @aliases;
		my $alias = EPrints::Utils::get_input( '^('.$REGEXP_HOSTNAME_MIDDLE.'|#)$', 'Alias (enter # when done)',
			(defined $default ? $default->{name} : '#' ) );
		last if( $alias eq "#" );
		my $aliasrecord = {};
		$aliasrecord->{name} = $alias;
		$aliasrecord->{redirect} = 
			EPrints::Utils::get_input( 
				$REGEXP_YESNO,
				"Redirect $alias to $config{host}",
				(defined $default && !$default->{redirect} ? 'no' : 'yes' ) );
		push @{$config{aliases}},$aliasrecord;
		print "\n";
	}

#print <<END;
#
#Language Configuration
#
#Please enter the primary language and other supported languages for the 
#repository. Supporting other languages represents a serious commitment to 
#translate all the phrases and templates etc. into each of these other 
#languages.
#
#Available languages: (please use the ID to refer to them)
#END
#my @langs = EPrints::Config::get_supported_languages();
#foreach( @langs )
#{
#	my $title = utf8("");
#	$title->utf8( "".EPrints::Config::lang_title( $_ ) );
#	print $_." - ".($title->latin1)."\n";
#}
#print <<END;
#
#If you plan to add support for another language, you will need to edit the 
#languages.xml file to indicate that this language is supported, and create 
#the relevant phrase and template files. 
#
#END

	print "\n";
	print "\n";

	$config{adminemail} = EPrints::Utils::get_input( $REGEXP_EMAIL, 'Administrator Email',  $config{adminemail} );
	print <<END;

Enter the name of the repository in the default language. If you wish to enter 
other titles for other languages or enter non ascii characters then you may
enter something as a placeholder and edit the XML config file which this
script generates.

END
	$config{archive_name} = EPrints::Utils::get_input( '^.+$', 'Archive Name',  $config{archive_name} );

	# Write files?

	print "\n";
	my $config_core = EPrints::Utils::get_input( $REGEXP_YESNO, "Write these core settings?", "yes" );
	if( $config_core eq "no" )
	{
		print "\nOK. Not writing after all.\n";
		return;
	}

	# Write files!

	my $repodir = EPrints::Config::get( "base_path" )."/archives/".$repoid;

	my $aemailfile = "$repodir/cfg/cfg.d/adminemail.pl";
	open( AEMAIL, ">$aemailfile" ) || die "Could not write to $aemailfile: $!";
	print AEMAIL Data::Dumper->Dump(
		[
			$config{adminemail}, 
		],
		[qw/
			$c->{adminemail} 
		/]
	);
	close AEMAIL;
	print "Wrote $aemailfile\n";

	my $corefile = "$repodir/cfg/cfg.d/10_core.pl";
	open( CORE, ">$corefile" ) || die "Could not write to $corefile: $!";
	print CORE Data::Dumper->Dump(
		[
			$config{host}, 
			$config{port},
			$config{aliases},
			$config{securehost},
			$config{secureport},
		],
		[qw/
			$c->{host} 
			$c->{port} 
			$c->{aliases} 
			$c->{securehost} 
			$c->{securepath}
		/]
	);
	close CORE;
	print "Wrote $corefile\n";

	my $anamefile = "$repodir/cfg/lang/en/phrases/archive_name.xml";
	open( ANAME, ">$anamefile" ) || die "Could not write to $anamefile: $!";
	print ANAME <<END;
<?xml version="1.0" encoding="iso-8859-1" standalone="no" ?>
<!DOCTYPE phrases SYSTEM "entities.dtd">

<epp:phrases xmlns="http://www.w3.org/1999/xhtml"
            xmlns:epp="http://eprints.org/ep3/phrase">

    <epp:phrase id="archive_name">$config{archive_name}</epp:phrase>

</epp:phrases>
END
	close( ANAME );
	print "Wrote $anamefile\n";
}

sub config_db
{
	my( $repoid ) = @_;

	my %config = ();
	$config{dbname} = $repoid;
	$config{dbhost} = "localhost";
	$config{dbport} = undef;
	$config{dbsock} = undef;
	$config{dbuser} = $repoid;
	$config{dbpass} = undef;

	print "\nConfiguring Database for: $repoid\n";

	$config{dbname} = EPrints::Utils::get_input( $REGEXP_VARNAME, 'Database Name',  $config{dbname} );
	$config{dbhost} = EPrints::Utils::get_input( $REGEXP_HOSTNAME, 'MySQL Host',  $config{dbhost} );

	print "\nYou probably don't need to set socket and port (unless you do!?).\n";
	$config{dbport} = "#" if( !defined $config{dbport} );
	$config{dbport} = EPrints::Utils::get_input( '^[0-9]+|#$', 'MySQL Port (# for no setting)',  $config{dbport} );
	$config{dbport} = undef if( $config{dbport} eq "#" );

	$config{dbsock} = "#" if( !defined $config{dbsock} );
	# can't remember what is a legal mysql socket... cjg
	$config{dbsock} = EPrints::Utils::get_input( '^.*$', 'MySQL Socket (# for no setting)',  $config{dbsock} );
	$config{dbsock} = undef if( $config{dbsock} eq "#" );

	my $defaultpass = $config{dbpass};
	if( !defined $config{dbpass} || $config{dbpass} eq "" )
	{
		$defaultpass = "";
		srand;
		for( 1..8 )
		{
			$defaultpass .= $PASSWORD_CHARS[int rand scalar @PASSWORD_CHARS];
		}
	}
	$config{dbuser} = EPrints::Utils::get_input( $REGEXP_VARNAME, 'Database User',  $config{dbuser} );
	$config{dbpass} = EPrints::Utils::get_input_hidden( $REGEXP_VARNAME, 'Database Password',  $defaultpass );

	print "\n";
	my $config_db = EPrints::Utils::get_input( $REGEXP_YESNO, "Write these database settings?", "yes" );
	if( $config_db eq "no" )
	{
		print "\nOK. Not writing after all.\n";
		return;
	}

	my $repodir = EPrints::Config::get( "base_path" )."/archives/".$repoid;
	my $dbfile = "$repodir/cfg/cfg.d/database.pl";
	open( DBCONF, ">$dbfile" ) || die "Could not write to $dbfile: $!";
	print DBCONF Data::Dumper->Dump(
		[
			$config{dbname}, 
			$config{dbhost},
			$config{dbport},
			$config{dbsock},
			$config{dbuser},
			$config{dbpass},
		],
		[qw/
			$c->{dbname} 
			$c->{dbhost}
			$c->{dbport}
			$c->{dbsock}
			$c->{dbuser}
			$c->{dbpass}
		/]
	);
	close DBCONF;
	print "Wrote $dbfile\n";

	print <<END;

EPrints can create the database, and grant the correct permissions.
	
END
	my $makedb = EPrints::Utils::get_input( $REGEXP_YESNO, "Create database \"$config{dbname}\"", "yes" );
	if( $makedb eq "yes" )
	{
		create_db( $repoid );
	}
	else
	{
		print "\nWell, OK. But you'll need to do it yourself then.\n";
	}

}

my $mysql_root_password;
# subroutine so that it can cache if we do several operations
sub get_mysql_root_password
{
	return $mysql_root_password if( defined $mysql_root_password );

	#cjg hide password from display?
	print <<END;

Ok, I'll need to connect to the mysql database as root. What is the root 
password? 
	
END
	$mysql_root_password = EPrints::Utils::get_input_hidden( '^.*$', "MySQL Root Password" );

	return $mysql_root_password;
}

sub root_dbh
{
	my( $repoid, $dbname ) = @_;

	EPrints::Config::init();
	my $config = EPrints::Config::load_repository_config_module( $repoid );

	$dbname = $config->{dbname} unless defined $dbname;

	my $dbh;
	
	while( !defined $dbh )
	{
		my $password = get_mysql_root_password();
		print "Connecting to the database...\n";
		$dbh = DBI->connect(
			EPrints::Database::build_connection_string(
				dbname=>$dbname,
				dbsock=>$config->{dbsock},
				dbport=>$config->{dbport},
				dbhost=>$config->{dbhost} ),
			"root",
			$password );

		if( !defined $dbh )
		{
			$mysql_root_password = undef;
			print "\nCould not connect to database: $DBI::errstr\n\n";
			my $try_again = EPrints::Utils::get_input( $REGEXP_YESNO, "Try again?", "yes" );
			if( $try_again eq "no" )
			{
				exit( 1 );
			}
		}
	}

	return $dbh;
}

sub create_db
{
	my( $repoid ) = @_;

	my $dbh = root_dbh( $repoid, "mysql" );

	if( !defined $dbh )
	{
		print <<END;

Hmmm. Problem connecting to database as root. We'll skip this but
you should create it by hand.

END
		exit 1;
	}

	use EPrints::Database::mysql;
	my $mversion = EPrints::Database::mysql::mysql_version_from_dbh( $dbh );
	my $oldpasswords = 0;
	if( $mversion >= 40100 ) 
	{
		print "MySQL version id $mversion >= 40100\n";
		print "MYSQL OLD PASSWORDS will be used for compatibility with DBI::mysql\n";
		$oldpasswords = 1;
	} 

	EPrints::Config::init();
	my $config = EPrints::Config::load_repository_config_module( $repoid );

	my $sth = $dbh->prepare( "show databases" );
	$sth->execute;
	my $dbexists = 0;
	my @row;
	while( @row = $sth->fetchrow_array )
	{
		$dbexists = 1 if $row[0] eq $config->{dbname};
	}
	if( $dbexists )
	{
		print "Hmm. A database called ".$config->{dbname}." already exists, oh well.\n\n";
		return;
	}
	else
	{
		my $SQL = "CREATE DATABASE ".$config->{dbname};
		#print "DOING: $SQL\n";
		$dbh->do( $SQL );
	}
	print "Setting MySQL privs\n";
	#cjg @localhost ??? what about remote mysql's?

	my $SQL;
	$SQL = 'GRANT ALL ON '.$config->{dbname}.'.* TO '.$config->{dbuser}.'@localhost';
	#print "DOING: $SQL\n";
	$dbh->do( $SQL );
	my $pass = '"'.$config->{dbpass}.'"';
	if( $oldpasswords ) 
	{
		$pass = "OLD_PASSWORD($pass)";
	} else {
		$pass = "PASSWORD($pass)";
	}
	$SQL = 'SET PASSWORD FOR '.$config->{dbuser}.'@localhost = '.$pass;
	#print "DOING: $SQL\n";
	$dbh->do( $SQL );

	print "Disconnecting from database.\n\n";
	$dbh->disconnect;

	my $mktables = EPrints::Utils::get_input( $REGEXP_YESNO, "Create database tables?", "yes" );
	if( $mktables eq "yes" )
	{
		create_tables( $repoid );
	}

}
 

sub create_user
{
	my( $repoid ) = @_;

	my $session = EPrints::Session->new( 1 , $repoid, $noise );
	if( !defined $session )
	{
		print STDERR "Failed to load repository: $repoid\n";
		exit 1;
	}

	my $user_info = {};
	@{$user_info}{qw( username usertype password email )} = @ARGV[2..$#ARGV];
	if( defined($user_info->{username}) &&
		$user_info->{username} eq "_" )
	{
		@{$user_info}{qw( username usertype password email )} = (
			"admin",
			"admin",
			"admin",
			"admin\@localhost",
		);
	}

	print "Creating a new user in $repoid\n\n";
	$user_info->{username} ||= EPrints::Utils::get_input( $REGEXP_VARNAME, 'Enter a username', 'admin' );
	while( defined EPrints::DataObj::User::user_with_username( $session, $user_info->{username} ) )
	{
		print STDERR "User with username '".$user_info->{username}."' already exists.\n";
		$user_info->{username} = EPrints::Utils::get_input( $REGEXP_VARNAME, 'Enter a username', 'admin' );
	}
	my @utypes = $session->get_repository->get_types( "user" );
	$user_info->{usertype} ||= EPrints::Utils::get_input( '^('.join( '|', @utypes ).')$', 'Select a user type ('.join( "|",@utypes).')', 'admin' );
	$user_info->{password} ||= EPrints::Utils::get_input_hidden( $REGEXP_VARNAME, 'Enter Password' );
	$user_info->{password} = EPrints::Utils::crypt_password( $user_info->{password}, $session );
	$user_info->{email} ||= EPrints::Utils::get_input( $REGEXP_EMAIL, 'Email' );
	
	my $user_ds = $session->get_repository->get_dataset( "user" );
	my $new_user = $user_ds->create_object( $session, $user_info );

	print "\n";

	if( defined $new_user )
	{
		if( $noise >= 1 )
		{
			print "Successfully created new user:\n";
			print "       ID: ".$new_user->get_value( "userid" )."\n";
		}
		if( $noise >= 2 )
		{
			print " Username: ".$new_user->get_value( "username" )."\n";
			print "     Type: ".$new_user->get_value( "usertype" )."\n";
		}
	}
	else
	{
		my $db_error = $session->get_database->error;
		print STDERR "Error creating user: $db_error\n";
	}
	$session->terminate;
}


sub redo_thumbnails
{
	my( $repoid, @ids ) = @_;

	my $session = new EPrints::Session( 1 , $repoid , $noise );
	if( !defined $session )
	{
		print STDERR "Failed to load repository: $repoid\n";
		exit 1;
	}

	my $mf = sub {
		my( $session , $dataset , $doc ) = @_;

		if( $noise >= 2 )
		{
			print "Attempting to build thumbnails (and other auto-conversions) for document #".$doc->get_id."\n";
		}

		$doc->remove_thumbnails; #ouch!
		$doc->make_thumbnails;
	};

	my $doc_ds = $session->get_repository->get_dataset( "document" );
	if( !@ids )
	{
		$doc_ds->map( $session, $mf );
	}
	else
	{
		my $dataset = $session->get_repository->get_dataset( "eprint" );
		for(@ids)
		{
			my $eprint = $dataset->get_object( $session, $_ );
			if( !defined $eprint )
			{
				print STDERR "No such eprint '$_'\n";
				next;
			}
			foreach my $doc ($eprint->get_all_documents)
			{
				&$mf( $session, $doc_ds, $doc );
			}
		}
	}

	$session->terminate;
}	


sub refresh_views
{
	my( $repoid ) = @_;

	my $session = new EPrints::Session( 1 , $repoid , $noise );
	if( !defined $session )
	{
		print STDERR "Failed to load repository: $repoid\n";
		exit 1;
	}
	
	my $file = $session->get_repository->get_conf( "variables_path" )."/views.timestamp";
	unless( open( CHANGEDFILE, ">$file" ) )
	{
		EPrints::abort( "Cannot write to file $file" );
	}
	print CHANGEDFILE "This file last poked at: ".EPrints::Time::human_time()."\n";
	close CHANGEDFILE;
	if( $noise > 0 )
	{
		print <<END;
View (Browse) pages will be updated when they are requested. The 
webserver will now be told to reload the apache configuration, although 
restarting the server at this point is slightly more efficient.

END
	}
	$session->terminate;

	reload( $repoid );
}	


sub refresh_abstracts
{
	my( $repoid ) = @_;

	my $session = new EPrints::Session( 1 , $repoid , $noise );
	if( !defined $session )
	{
		print STDERR "Failed to load repository: $repoid\n";
		exit 1;
	}
	
	my $file = $session->get_repository->get_conf( "variables_path" )."/abstracts.timestamp";
	unless( open( CHANGEDFILE, ">$file" ) )
	{
		EPrints::abort( "Cannot write to file $file" );
	}
	print CHANGEDFILE "This file last poked at: ".EPrints::Time::human_time()."\n";
	close CHANGEDFILE;
	if( $noise > 0 )
	{
		print <<END;
Abstract (Summary) pages will be updated when they are requested. The 
webserver will now be told to reload the apache configuration, although 
restarting the server at this point is slightly more efficient.

END
	}
	$session->terminate;

	reload( $repoid );
}	

sub reload
{
	my( $repoid ) = @_;

	my $session = new EPrints::Session( 1 , $repoid , $noise );
	if( !defined $session )
	{
		print STDERR "Failed to load repository: $repoid\n";
		exit 1;
	}
	
	my $file = $session->get_repository->get_conf( "variables_path" )."/last_changed.timestamp";
	unless( open( CHANGEDFILE, ">$file" ) )
	{
		EPrints::abort( "Cannot write to file $file" );
	}
	print CHANGEDFILE "This file last poked at: ".EPrints::Time::human_time()."\n";
	close CHANGEDFILE;
	if( $noise > 0 )
	{
		print <<END;
The repository config will be reloaded, but you should still restart apache as
soon as possible.

END
	}
	$session->terminate;
}	

sub reload_metafields
{
	my( $repoid ) = @_;

	my $session = new EPrints::Session( 1 , $repoid , $noise );
	if( !defined $session )
	{
		print STDERR "Failed to load repository: $repoid\n";
		exit 1;
	}

	my $dataset = $session->get_repository->get_dataset( "metafield" );
	$dataset->map( $session, sub {
		my( undef, undef, $mf ) = @_;
		$mf->remove();
	});

	my $list = EPrints::DataObj::MetaField::load_all( $session );
	print "Loaded ".$list->count." metafields\n";
}	

sub create_tables
{
	my( $repoid ) = @_;

	my $session = new EPrints::Session( 1 , $repoid , $noise, 1 );
	if( !defined $session )
	{
		print STDERR "Failed to load repository: $repoid\n";
		exit 1;
	}

	if( $session->get_database->has_table( "eprint" ) )
	{
		print "WARNING: Database is NOT empty. Contains an \"eprint\" table.\n";
		print "You might consider running 'epadmin erase_data $repoid' instead.\n";
		$session->terminate;
		exit 1;
	}

	foreach my $dsid ( $session->get_repository->get_sql_dataset_ids )
	{
		my $ds = $session->get_repository->get_dataset( $dsid );
		my $indexes = $ds->count_indexes;
		if( $indexes > 32 )
		{
			print STDERR "WARNING: Main table of dataset \"$dsid\" requires $indexes indexes.\n";
			$session->terminate;
			EPrints::abort( "MySQL has a maximum of 32 indexes per table and the '$dsid'\ntable requires $indexes. Add an sql_index=>0 parameter to some of the\nfields in this dataset. See the Documentation for more information\non the 'sql_index' metadata parameter. --force will override this\ncheck but the SQL will probably fail anyway." );
		}
	}
			
	if( $noise>=1 ) { print "Creating database tables...\n"; }
	if( $session->get_database->create_archive_tables )
	{
		if( $noise>=1 ) { print "Done creating database tables.\n\n"; }
	}
	else
	{
		my $error = $session->get_database->error;
		print STDERR "DB Error: $error\n";
		$session->terminate;
		exit 1;
	}
}

sub erase_data
{
	my( $repoid ) = @_;

	print <<END;
You are about to erase from $repoid:
  - all database tables
  - all eprint files
  - the generated html pages
but NOT the configuration files.

END
	
	my $sure = $force || EPrints::Utils::get_input_confirm( "Are you sure you want this to happen" );
	unless( $sure )
	{
		print "Aborting then.\n";
		exit( 1 );
	}

	erase_eprint_files( $repoid );
	drop_tables_and_recreate_db( $repoid );
}

sub erase_eprints
{
	my( $repoid ) = @_;

	print <<END;
You are about to erase from $repoid:
  - all eprints and documents data
  - all eprint files
  - all change history
  - the document requests
  - the access logs
  - the generated html pages
but NOT the configuration files, user data or subject data.

END
	
	my $sure = EPrints::Utils::get_input_confirm( "Are you sure you want this to happen" );
	unless( $sure )
	{
		print "Aborting then.\n";
		exit( 1 );
	}

	erase_eprint_files( $repoid );
	foreach( "eprint", "history","access","request","document","file" )
	{
		reset_dataset( $repoid, $_ );
	}		
	
	my $ok;
	$ok = EPrints::Utils::get_input( $REGEXP_YESNO, "Do you want to build the static web pages?", "yes" );
	if( $ok eq "yes" )
	{
		run_script( $repoid, "generate_static", "--verbose", $repoid );	
	}
}

sub reset_dataset
{
	my( $repoid, $datasetid ) = @_;

	my $session = new EPrints::Session( 1 , $repoid , $noise, 1 );
	if( !defined $session )
	{
		print STDERR "Failed to load repository: $repoid\n";
		exit 1;
	}

	my $db = $session->get_database;
	my @tables = $db->get_tables;
	print "Erasing dataset $datasetid\n" if( $noise >= 1 );
	foreach my $table ( @tables )
	{
		next unless( $table =~ m/^$datasetid/ );
		print "Erasing table $table\n" if( $noise >= 2 );
		$db->clear_table($table);
	}

	if( $datasetid ne "subject" )
	{
		print "Resetting counter ${datasetid}id\n";
		$db->counter_reset( $datasetid."id" );
	}

	$session->terminate;
}

sub drop_tables_and_recreate_db
{
	my( $repoid ) = @_;

	my $session = new EPrints::Session( 1 , $repoid , $noise, 1 );
	if( !defined $session )
	{
		print STDERR "Failed to load repository: $repoid\n";
		exit 1;
	}

	my $db = $session->get_database;

	my @tables = $db->get_tables;

	foreach my $datasetid ($session->get_repository->get_sql_dataset_ids())
	{
		my $dataset = $session->get_repository->get_dataset( $datasetid );
		my $sql_name = $dataset->get_sql_table_name;
		if( $noise>=2 ) { print "Removing dataset $datasetid [$sql_name]\n"; }
		foreach my $table (@tables)
		{
			$db->drop_table( $table )
				if $table eq $sql_name or $table =~ /^$sql_name\_/i;
		}
	}

	if( $noise>=2 ) { print "Cleaning up cache tables\n"; }
	foreach my $table (@tables)
	{
		if( $table =~ /^cache\d+$/i )
		{
			if( $noise>=3 ) { print "Dropping $table\n"; }
			$db->drop_table( $table );
		}
	}

	if( $noise>=2 ) { print "Removing counters\n"; }
	$db->remove_counters();

	for(qw( version ))
	{
		if( $noise>=2 ) { print "Removing support table $_\n"; }
		$db->drop_table( $_ ) if $db->has_table( $_ );
	}

	my $mktables = $force || EPrints::Utils::get_input_confirm( "Create database tables?", 0, 1 ); # not quick, default to "yes"
	if( $mktables )
	{
		create_tables( $repoid );
	}

	$session->terminate;
}

# not an option directly!
sub drop_and_recreate_db
{
	my( $repoid ) = @_;

	my $repo = EPrints::Repository->new( $repoid );
	my $database = $repo->get_conf( "dbname" );
	
	if( $noise>=1 ) { print "Connecting to mysql...\n"; }

	my $dbh = root_dbh( $repoid, "mysql" );

	if( !defined $dbh )
	{
		print STDERR "\n\nFailed to connect to database. Aborting.\n\n";
		exit( 1 );
	}

	if( $noise>=1 ) { print "Dropping database \"$database\"\n"; }
	$dbh->do( "drop database $database" );
	if( $noise>=1 ) { print "Re-creating database \"$database\"\n"; }
	$dbh->do( "create database $database" );
	$dbh->disconnect;

	if( $noise>=1 ) { print "Done recreating database\n\n"; }

	my $mktables = EPrints::Utils::get_input( $REGEXP_YESNO, "Create database tables?", "yes" );
	if( $mktables eq "yes" )
	{
		create_tables( $repoid );
	}
}

# not an option directly!
sub erase_eprint_files
{
	my( $repoid ) = @_;

	if( $noise>=1 ) { print "Erasing eprint files...\n"; }

	my $repo = EPrints::Repository->new( $repoid );
	my $documents_path = $repo->get_conf( "documents_path" );
	my $htdocs_path = $repo->get_conf( "htdocs_path" );
	
	# Get available directories
	opendir DOCSTORE, $documents_path
		or print STDERR "Can't open DOCSTORE\n";
	
	my @doomeddirs;
	foreach( readdir DOCSTORE )
	{
		next if m/^\./; # skip . and .. and any hidden directories
		push @doomeddirs,
			$documents_path."/".$_;
	}
	closedir DOCSTORE;
	
	# Remove the contents of each of the directories.

	push @doomeddirs, $htdocs_path;
	foreach my $dir (@doomeddirs)
	{
		if( $noise>=2 ) { print "Removing stuff in: $dir\n"; }
		my $rc = $repo->exec( "rmall", TARGET=>$dir );
		print STDERR "Warning: Cleaning $dir didn't go smoothly\n" unless( $rc==0 );
	}
	if( $noise>=1 ) { print "...done erasing eprint files.\n"; }
}

sub erase_fulltext_index
{
	my( $repoid ) = @_;

	my $session = new EPrints::Session( 1 , $repoid , $noise );
	if( !defined $session )
	{
		print STDERR "Failed to load repository: $repoid\n";
		exit 1;
	}

	my $ds = $session->get_repository->get_dataset( "document" );
	print "Stating to erase caches\n" if( $noise >= 1 );

	$ds->map( $session, sub {
			my( undef, undef, $doc ) = @_;

			if( $noise >= 2 )
			{
				print "Removing fulltext index for: ".$doc->get_id."\n";
			}
			
			$doc->remove_indexcodes();
		} );

	print "Done erasing\n" if( $noise >= 1 );
	print "Queuing records for re-indexing\n" if( $noise >= 1 );

	my $fn = sub {
		my( $session, $dataset, $item ) = @_;
	
		$item->queue_fulltext();

		if( $session->get_noise() >= 2 )
		{
			print STDERR "Queued item: ".$dataset->id()."/".$item->get_id()."\n";
		}
	};

	my $ep_ds = $session->get_repository->get_dataset( "eprint" );
	$ep_ds->map( $session, $fn );

	print "Done queuing\n" if( $noise >= 1 );

	$session->terminate;
}

sub test
{
	my( $repoid ) = @_;

	if( !defined $repoid )
	{
		foreach( EPrints::Config::get_repository_ids() )
		{
			print "REPOID: $_\n" if $noise > 1;
			test( $_ );
		}
		return;
	}

	my $session = new EPrints::Session( 1 , $repoid , $noise );
	if( !defined $session )
	{
		print STDERR "Failed to load repository: $repoid\n";
		exit 1;
	}
	
	if( $noise > 1 )
	{
		print "PID: $$\n";
		eval "use GTop";
		if( !$@ )
		{
			my $size = GTop->new->proc_mem( $$ )->resident;
			print "SIZE: $size\n";
		}
	}
	$session->terminate;

	print "Everything seems OK.\n";
}

sub profile
{
	my( $test ) = @_;

	unless( defined $test )
	{
		die "Requires test argument\n";
	}

	eval "use Test::Harness";
	if( $@ )
	{
		die "Can't do profiling without Test::Harness: $@";
	}

	eval "use Devel::NYTProf";
	if( $@ )
	{
		die "Can't do profiling without Devel::NYTProf: $@";
	}

	my $base_path = $EPrints::SystemSettings::conf->{base_path};
	my $test_path = "$base_path/tests";

	my $test_file = "$test_path/$test";
	$test_file =~ s/(\.pl)?$/.pl/;

	unless( -f $test_file )
	{
		die "Test '$test' not found in $test_path/\n";
	}

	$ENV{HARNESS_PERL_SWITCHES} = "-d:NYTProf";

	exit(0) if runtests($test_file);
}

sub unit_tests
{
	my( @todo ) = @_;

	my %todo = map { $_ => 1 } @todo;

	eval "use Test::Harness";
	if( $@ )
	{
		die "Can't do unit tests without Test::Harness: $@";
	}

	my $base_path = $EPrints::SystemSettings::conf->{base_path};
	my $test_path = "$base_path/tests";

	opendir( DIR, $test_path ) or die "Unable to open unit test path $test_path: $!";
	my @test_files = grep { -f "$test_path/$_" && $_ !~ /^\./ && $_ =~ /\.pl$/ } readdir( DIR );
	closedir( DIR );

	@test_files = sort { $a cmp $b } @test_files;
	if( scalar(@todo) )
	{
		@test_files = grep { $todo{$_} or $todo{substr($_,0,-3)} } @test_files;
	}

	exit(0) if runtests(map { "$test_path/$_" } @test_files);
}

sub rehash
{
	my( $repoid ) = @_;

	my $session = new EPrints::Session( 1 , $repoid , $noise );
	if( !defined $session )
	{
		print STDERR "Failed to load repository: $repoid\n";
		exit 1;
	}

	my $docid = $ARGV[2];
	if( defined $docid )
	{
		my $doc = EPrints::DataObj::Document->new( $session, $docid );
		if( !defined $doc )
		{
			$session->get_repository->log( 
	"Document #$docid not found. Can't rehash." );
		}
		else
		{
			$doc->rehash;
			print "Rehashed document #$docid\n" if( $noise > 0);
		}
	}
	else
	{
		print "Rehashing documents\n" if( $noise > 0);
		my $dataset = $session->get_repository->get_dataset( "document" );
		my $info = { count=>0 };
		$dataset->map( 
			$session , 
			sub 
			{
				my( $session, $dataset, $doc, $info ) = @_;
				$doc->rehash;
				if( $noise > 1 )
				{
					print "Rehashed ".$doc->get_value( "docid" )."\n";
				}
				$info->{count}++;
			},
			$info );

		if( $noise > 0)
		{
			print "Done rehashing ".$info->{count}." documents\n";
		}
	}

	$session->terminate;
}

###################################
#
# DATASET related utilities
#
###################################


sub recommit
{
	my( $repoid, $datasetid ) = @_;

	my $session = new EPrints::Session( 1 , $repoid , $noise );
	if( !defined $session )
	{
		print STDERR "Failed to load repository: $repoid\n";
		exit 1;
	}

	my $dataset = $session->get_repository->get_dataset( $datasetid );
	if( !defined $dataset )
	{
		print "Exiting due to unknown dataset.\n" if( $noise >= 1 );
		$session->terminate();
		exit( 1 );
	}

        if( $noise > 0 )
        {
                print "\n";
                print "You are about to recommit \"$datasetid\" in the $repoid repository.\n";
                print "This can take some time.\n\n";
                print "Number of records in set: ".$dataset->count( $session )."\n";
        }

        my $sure = EPrints::Utils::get_input_confirm( "Continue" );
        unless( $sure )
        {
                print "Aborting then.\n\n";
                $session->terminate();
                exit( 1 );
        }


	my $fn = sub {
        	my( $session, $dataset, $item ) = @_;
	
        	if( $session->get_noise() >= 2 )
        	{
                	print STDERR "Committing item: ".$dataset->id()."/".$item->get_id()."\n";
        	}
        	$item->commit();
	};

	$dataset->map( $session, $fn );

	print "All items in \"$datasetid\" have been re-commited.\n" if( $noise >= 1 );

	$session->terminate;
}

sub reorder
{
	my( $repoid, $datasetid ) = @_;

	my $session = new EPrints::Session( 1 , $repoid , $noise );
	if( !defined $session )
	{
		print STDERR "Failed to load repository: $repoid\n";
		exit 1;
	}

	my $dataset = $session->get_repository->get_dataset( $datasetid );
	if( !defined $dataset )
	{
		print "Exiting due to unknown dataset.\n" if( $noise >= 1 );
		$session->terminate();
		exit( 1 );
	}

	my $fn = sub {
		my( $session, $dataset, $item ) = @_;
	
		EPrints::Index::update_ordervalues( $session, $dataset, $item->{data} );

		if( $session->get_noise() >= 2 )
		{
			print STDERR "Re-ordered item: ".$dataset->id()."/".$item->get_id()."\n";
		}
	};

	$dataset->map( $session, $fn );

	$session->terminate;
}

sub reindex
{
	my( $repoid, $datasetid ) = @_;

	my $session = new EPrints::Session( 1 , $repoid , $noise );
	if( !defined $session )
	{
		print STDERR "Failed to load repository: $repoid\n";
		exit 1;
	}

	my $dataset = $session->get_repository->get_dataset( $datasetid );
	if( !defined $dataset )
	{
		print "Exiting due to unknown dataset.\n" if( $noise >= 1 );
		$session->terminate();
		exit( 1 );
	}

	my $fn = sub {
		my( $session, $dataset, $item ) = @_;
	
		$item->queue_all();
		if( $item->get_dataset->base_id eq "eprint" )
		{
			$item->queue_fulltext();
		}

		if( $session->get_noise() >= 2 )
		{
			print STDERR "Queued item: ".$dataset->id()."/".$item->get_id()."\n";
		}
	};

	$dataset->map( $session, $fn );

	$session->terminate;
}


sub schema 
{
	my( $repoid ) = @_;

	my $session = new EPrints::Session( 1 , $repoid , $noise );
	if( !defined $session )
	{
		print STDERR "Failed to load repository: $repoid\n";
		exit 1;
	}

	my $mf_dataset = $session->get_repository->get_dataset( "metafield" );

	my $plugin = $session->plugin( "Export::XML_Schema" );

	my $list = EPrints::List->new(
		dataset => $mf_dataset,
		session => $session,
		ids=>["ALL"] );

	print $plugin->byte_order_mark;
	$plugin->output_list( list=>$list, fh=>*STDOUT );

	undef $list;

	$session->terminate;
}




####################################################################
#
#  UPGRADE CODE	
#
####################################################################

sub upgrade
{
	my( $repoid ) = @_;

	my $session = new EPrints::Session( 1 , $repoid , $noise, 1 );
	if( !defined $session )
	{
		print STDERR "Failed to load repository: $repoid\n";
		exit 1;
	}
	
	my $db = $session->get_db();
	my $dbversion = $db->get_version();
	
	if( $dbversion eq "3.0" )
	{
		upgrade_3_0_to_3_0_1( $repoid, $db );
		$dbversion="3.0.1";
		$db->set_version( $dbversion );
	}
	if( $dbversion eq "3.0.1" )
	{
		upgrade_3_0_1_to_3_0_2( $repoid, $db );
		$dbversion="3.0.2";
		$db->set_version( $dbversion );
	}
	if( $dbversion eq "3.0.2" )
	{
		upgrade_3_0_2_to_3_0_3( $repoid, $db );
		$dbversion="3.0.3";
		$db->set_version( $dbversion );
	}
	if( $dbversion eq "3.0.3" )
	{
		upgrade_3_0_3_to_3_0_4( $repoid, $db );
		$dbversion="3.0.4";
		$db->set_version( $dbversion );
	}
	if( $dbversion eq "3.0.4" )
	{
		upgrade_3_0_4_to_3_0_5( $repoid, $db );
		$dbversion="3.0.5";
		$db->set_version( $dbversion );
	}
	if( $dbversion eq "3.0.5" )
	{
		upgrade_3_0_5_to_3_0_6( $repoid, $db );
		$dbversion="3.0.6";
		$db->set_version( $dbversion );
	}
	if( $dbversion eq "3.0.6" )
	{
		upgrade_3_0_6_to_3_0_7( $repoid, $db );
		$dbversion="3.0.7";
		$db->set_version( $dbversion );
	}
	if( $dbversion eq "3.0.7" )
	{
		upgrade_3_0_7_to_3_1_0( $repoid, $db );
		$dbversion="3.1.0";
		$db->set_version( $dbversion );
	}
	if( $dbversion eq "3.1.0" )
	{
		upgrade_3_1_0_to_3_1_1( $repoid, $db );
		$dbversion="3.1.1";
		$db->set_version( $dbversion );
	}
	if( $dbversion eq "3.1.1" )
	{
		upgrade_3_1_1_to_3_1_2( $repoid, $db );
		$dbversion="3.1.2";
		$db->set_version( $dbversion );
	}
	if( $dbversion eq "3.1.2" )
	{
		upgrade_3_1_2_to_3_2_0( $repoid, $db );
		$dbversion="3.2.0";
		$db->set_version( $dbversion );
	}


	print $dbversion."\n";
	$session->terminate;
}

# This will check for any missing datasets or fields and add them
sub update_datasets
{
	my( $repo, $db ) = @_;

	my $success = 1;
	my $count = 0;
	my $field_count = 0;

	foreach( $repo->get_sql_dataset_ids() )
	{
		my $dataset = $repo->get_dataset( $_ );
		if( !$db->has_dataset( $dataset ) )
		{
			if( $db->create_dataset_tables( $dataset ) )
			{
				++$count;
				print "Added dataset $_\n" if $noise;
			}
			else
			{
				$success = 0;
				print STDERR "Failed adding dataset $_\n";
			}
		}
		foreach my $field ($dataset->get_fields)
		{
			next if defined $field->get_property( "sub_name" );
			if( !$db->has_field( $dataset, $field ) )
			{
				if( $db->add_field( $dataset, $field ) )
				{
					++$field_count;
					print "Added ".$field->get_name." to dataset $_\n" if $noise;
				}
				else
				{
					$success = 0;
					print STDERR "Failed adding ".$field->get_name." to dataset $_\n";
				}
			}
		}
	}

	print "$count datasets added\n" if $noise;
	print "$field_count fields added\n" if $noise;

	return $success;
}

# This will check for any missing counters and add them
sub update_counters
{
	my( $repo, $db ) = @_;

	my $success = 1;
	my $count = 0;

	foreach( $repo->get_sql_counter_ids )
	{
		if( !$db->has_counter( $_ ) )
		{
			if( $db->create_counter( $_ ) )
			{
				++$count;
				print "Added counter $_\n" if $noise;
			}
			else
			{
				$success = 0;
				print STDERR "Failed adding counter $_\n";
			}
		}
	}

	print "$count counters were added\n" if $noise;

	return $success;
}

sub upgrade_3_0_to_3_0_1
{
	my( $repoid, $db ) = @_;

	my $rootdbh = root_dbh( $repoid );
	if( !defined $rootdbh ) { die "Could not open database as root"; }
	my @tables = $db->get_tables;
	my $sql;

	$sql = "ALTER TABLE saved_search ADD public set('TRUE','FALSE') default 'FALSE' AFTER mailempty";
	$rootdbh->do( $sql );

	$sql = "CREATE TABLE user_items_fields ( userid INT NOT NULL, pos INT, items_fields VARCHAR(255) default NULL, KEY userid (userid), KEY pos (pos) )  ";
	$rootdbh->do( $sql );

	$sql = "CREATE TABLE user_review_fields ( userid INT NOT NULL, pos INT, review_fields VARCHAR(255) default NULL, KEY userid (userid), KEY pos (pos) )  ";
	$rootdbh->do( $sql );

	foreach my $table ( @tables )
	{
		if( $table =~ m/^saved_search__ordervalues_.*$/ )
		{
			$sql = "ALTER TABLE $table ADD public TEXT AFTER mailempty",
			$rootdbh->do( $sql );
		}
		if( $table =~ m/^user__ordervalues_.*$/ )
		{
			$sql = "ALTER TABLE $table ADD items_fields TEXT AFTER mailempty",
			$rootdbh->do( $sql );
			$sql = "ALTER TABLE $table ADD review_fields TEXT AFTER items_fields",
			$rootdbh->do( $sql );
		}
	}

	$rootdbh->disconnect;
}



sub upgrade_3_0_1_to_3_0_2
{
	my( $repoid, $db ) = @_;

	my $rootdbh = root_dbh( $repoid );
	if( !defined $rootdbh ) { die "Could not open database as root"; }
	my @tables = $db->get_tables;
	my $sql;

	$sql = "ALTER TABLE saved_search ADD name VARCHAR(255) NOT NULL AFTER pos";
	$rootdbh->do( $sql );

	$sql = "ALTER TABLE cachemap ADD userid INTEGER AFTER lastused";
	$rootdbh->do( $sql );

	foreach my $table ( @tables )
	{
		if( $table =~ m/^saved_search__ordervalues_.*$/ )
		{
			$sql = "ALTER TABLE $table ADD name TEXT AFTER pos",
			$rootdbh->do( $sql );
		}
	}

	$rootdbh->disconnect;
}

sub upgrade_3_0_2_to_3_0_3
{
	my( $repoid, $db ) = @_;

	my $rootdbh = root_dbh( $repoid );
	if( !defined $rootdbh ) { die "Could not open database as root"; }
	my @tables = $db->get_tables;
	my $sql;

	$sql = "ALTER TABLE eprint DROP fileinfo";
	$rootdbh->do( $sql );

	$sql = "ALTER TABLE eprint ADD fileinfo TEXT AFTER contact_email";
	$rootdbh->do( $sql );

	foreach my $table ( @tables )
	{
		if( $table =~ m/^eprint__ordervalues_.*$/ )
		{
			$sql = "ALTER TABLE $table DROP fileinfo";
			$rootdbh->do( $sql );
			$sql = "ALTER TABLE $table ADD fileinfo TEXT AFTER contact_email",
			$rootdbh->do( $sql );
		}
	}

	$rootdbh->disconnect;
}



sub upgrade_3_0_3_to_3_0_4
{
	my( $repoid, $db ) = @_;

	my $rootdbh = root_dbh( $repoid );
	if( !defined $rootdbh ) { die "Could not open database as root"; }
	my @tables = $db->get_tables;
	my $sql;

	$sql = "ALTER TABLE eprint ADD latitude FLOAT AFTER fileinfo";
	$rootdbh->do( $sql );
	$sql = "ALTER TABLE eprint ADD longitude FLOAT AFTER latitude";
	$rootdbh->do( $sql );
	$sql = "ALTER TABLE user ADD latitude FLOAT AFTER mailempty";
	$rootdbh->do( $sql );
	$sql = "ALTER TABLE user ADD longitude FLOAT AFTER latitude";
	$rootdbh->do( $sql );

	foreach my $table ( @tables )
	{
		if( $table =~ m/^eprint__ordervalues_.*$/ )
		{
			$sql = "ALTER TABLE $table ADD latitude TEXT AFTER fileinfo";
			$rootdbh->do( $sql );
			$sql = "ALTER TABLE $table ADD longitude TEXT AFTER latitude";
			$rootdbh->do( $sql );
		}
		if( $table =~ m/^user__ordervalues_.*$/ )
		{
			$sql = "ALTER TABLE $table ADD latitude TEXT AFTER review_fields";
			$rootdbh->do( $sql );
			$sql = "ALTER TABLE $table ADD longitude TEXT AFTER latitude";
			$rootdbh->do( $sql );
		}
	}

	$rootdbh->disconnect;
}


sub upgrade_3_0_4_to_3_0_5
{
	my( $repoid, $db ) = @_;

	$db->_create_messages_table;
}



sub upgrade_3_0_5_to_3_0_6
{
	my( $repoid, $db ) = @_;

	reset_dataset( $repoid, 'subject' );
}


sub upgrade_3_0_6_to_3_0_7
{
	my( $repoid, $db ) = @_;

	my $repo = EPrints::Repository->new( $repoid );
	foreach my $datasetid ( qw/
			access document eprint history
			request saved_search subject user /)
	{
		my $dataset = $repo->get_dataset( $datasetid );
		$db->add_index_to_indextable( $dataset );
	}

}

sub upgrade_3_0_7_to_3_1_0
{
	my( $repoid, $db ) = @_;

	my $repo = EPrints::Repository->new( $repoid );

	# Expand id primary keys to id-pos on multiple fields
	foreach my $datasetid ( qw/
			access document eprint history
			request saved_search subject user /)
	{
		my $dataset = $repo->get_dataset( $datasetid );
		foreach my $field ($dataset->get_fields)
		{
			next unless $field->get_property( "multiple" );
			next if $field->is_virtual;
			my $table = $dataset->get_sql_sub_table_name( $field );
			next unless $db->has_table( $table );
			my $keyfield = $dataset->get_key_field;
			unless( $db->get_primary_key( $table ) )
			{
				$db->do("ALTER TABLE $table DROP PRIMARY KEY");
			}
			$db->do("ALTER TABLE $table ADD PRIMARY KEY(".$keyfield->get_sql_name.",pos)");
		}
	}

	# access dataset changes
	my $dataset = $repo->get_dataset( "access" );
	my $table = $dataset->get_sql_table_name;

	# remove the 'urn:ip:' and 'info:oai:...:' bits
	$db->do("UPDATE $table SET
		referent_id=SUBSTRING_INDEX(referent_id,':',-1),
		referent_docid=SUBSTRING_INDEX(referent_docid,'-',-1),
		requester_id=SUBSTRING_INDEX(requester_id,'urn:ip:',-1)
	");
	my $changes_sql = '';
	$changes_sql .= "MODIFY referring_entity_id LONG,";
	$changes_sql .= "MODIFY referent_id INT,";
	$changes_sql .= "MODIFY referent_docid INT,";
	chop($changes_sql);
	$db->do("ALTER TABLE $table $changes_sql");

	# remove the index and order tables
	for(qw(__index __index_grep __rindex))
	{
		$db->drop_table("$table$_");
	}

	for($db->get_tables)
	{
		$db->drop_table($_) if /^cache(\d+)$/;
	}

	$db->drop_table( "messages" );
	$db->drop_table( "login_tickets" );
	$db->drop_table( "cachemap" );

	update_datasets( $repo, $db );
	update_counters( $repo, $db );
}


# undocumented option - use with caution!
sub update_database_structure
{
	my( $repoid ) = @_;

	my $session = new EPrints::Session( 1 , $repoid , $noise );
	if( !defined $session )
	{
		print STDERR "Failed to load repository: $repoid\n";
		exit 1;
	}
	
	my $db = $session->get_db();
	my $repo = $session->get_repository();

	update_datasets( $repo, $db );
	update_counters( $repo, $db );

	$session->terminate;
}

sub upgrade_3_1_0_to_3_1_1
{
	my( $repoid, $db ) = @_;

	my $repo = EPrints::Repository->new( $repoid );

	update_datasets( $repo, $db );
}

sub upgrade_3_1_1_to_3_1_2
{
	my( $repoid, $db ) = @_;

	my $repo = EPrints::Repository->new( $repoid );

	update_datasets( $repo, $db );
	update_counters( $repo, $db );

	foreach( $repo->get_sql_dataset_ids() )
	{
		my $dataset = $repo->get_dataset( $_ );

		foreach my $field ($dataset->get_fields)
		{
			next unless $field->isa( "EPrints::MetaField::Name" );

			my $table;
			if( $field->get_property( "multiple" ) )
			{
				$table = $dataset->get_sql_sub_table_name( $field );
			}
			else
			{
				$table = $dataset->get_sql_table_name();
			}
			my @logic;
			for($field->get_sql_names)
			{
				my $q_name = $db->quote_identifier( $_ );
				push @logic, "($q_name is not Null AND $q_name != '')";
			}
			my $logic = "(" . join(" OR ", @logic) . ")";
			for($field->get_sql_names)
			{
				my $q_name = $db->quote_identifier( $_ );
				my $q_table = $db->quote_identifier( $table );
				my $sql = "UPDATE $q_table SET $q_name='' WHERE $q_name is Null AND $logic";
				$db->do( $sql );
			}
		}
	}
}

sub upgrade_3_1_2_to_3_2_0
{
	my( $repoid, $db ) = @_;

	my $repo = EPrints::Repository->new( $repoid );

	# We can do this now, because we only ever add columns
	update_datasets( $repo, $db );
	update_counters( $repo, $db );

	if( ref($db) eq "EPrints::Database::mysql" )
	{
		upgrade_mysql_charset( $repoid, $db );
	}
}

sub upgrade_mysql_charset
{
	my( $repoid, $db ) = @_;

	my $session = EPrints::Session->new( 1, $repoid, 0, 1 );
	if( !defined $session )
	{
		print STDERR "Failed to load repository: $repoid\n";
		exit 1;
	}

	my $repo = $session->get_repository;

#	$db->do("LOCK TABLES version WRITE");

	print "CREATE(_utf8_test): ";
	$db->do("CREATE TEMPORARY TABLE _utf8_test LIKE version");

	my $collation = $db->get_column_collation( "_utf8_test", "version" );
	if( !defined $collation )
	{
		EPrints::abort "Error interogating current collation";
	}

	print " collation is $collation: ";
	if( 0 && $collation =~ /^utf8_/ )
	{
		print " [ Failed ]\n";
		print STDERR <<EOW;
Warning! It looks like your database tables are already set to use
UTF-8. If this is unexpected then any non-English characters in
your database may be double-encoded. You would see this as corrupt
characters when viewed from EPrints or a MySQL client. This
situation is recoverable but can not be identified or fixed by
this upgrade.

The upgrade will continue.

EOW
		return;
	}
	elsif( 0 && $collation !~ /^latin1_/ )
	{
		print " [ Failed ]\n";
		EPrints::abort <<EOW;
I don't understand the '$collation' collation. Your MySQL server
is configured in a way that this upgrade script doesn't support.
You need to manually correct this problem before an upgrade can
succeed.

EOW
		return;
	}

	print " [ OK ]\n";

	my $rc = $db->do("ALTER TABLE _utf8_test MODIFY version BINARY(255)");
	$rc &&= $db->do("ALTER TABLE _utf8_test MODIFY version VARCHAR(255) CHARACTER SET utf8");

	if( !$rc )
	{
		EPrints::abort <<EOW;
An unexpected error occurred while attempting to convert tables to UTF-8.
EOW
	}

	# convert all textual columns
	foreach( $repo->get_sql_dataset_ids() )
	{
		my $dataset = $repo->get_dataset( $_ );
		my $key_field = $dataset->get_key_field();
		my %colspecs;
		if( $key_field->isa( "EPrints::MetaField::Text" ) ||
			$key_field->isa( "EPrints::MetaField::Set" ) )
		{
			upgrade_mysql_charset_ordervalues( \%colspecs, $session, $db, $dataset, $key_field, 1 );
		}
		if( $dataset->indexable )
		{
			my $Q_table = $dataset->get_sql_index_table_name;
			$colspecs{$Q_table} = { binary => [], char => [] };
			push @{$colspecs{$Q_table}->{binary}},
				"`fieldword` BINARY(255)",
				"`ids` BLOB";
			push @{$colspecs{$Q_table}->{char}},
				"`fieldword` VARCHAR(255) CHARACTER SET utf8",
				"`ids` TEXT CHARACTER SET utf8";
		}
		foreach my $field ($dataset->get_fields)
		{
#print STDERR $dataset->confid.".".$field->get_name."[".$field->get_type."]\n";
			# upgrade main table
			if( !$field->is_virtual() &&
				($field->isa( "EPrints::MetaField::Text" ) ||
				$field->isa( "EPrints::MetaField::Set" )) )
			{
				upgrade_mysql_charset_field( \%colspecs, $session, $db, $dataset, $field );
			}
			# upgrade ordervalues table
			if( $field->get_name ne $key_field->get_name )
			{
				upgrade_mysql_charset_ordervalues( \%colspecs, $session, $db, $dataset, $field );
			}
		}
		while(my( $Q_table, $specs ) = each %colspecs)
		{
			my $binary_sql = "ALTER TABLE $Q_table ".
				join(", ", map { "MODIFY $_" } @{$specs->{binary}});
			my $sql = "ALTER TABLE $Q_table ".
				join(", ", map { "MODIFY $_" } @{$specs->{char}});
			$rc &&= $db->do($binary_sql);
			$rc &&= $db->do($sql);
		}
	}

	# don't need to go via binary because these should only contain US-ASCII
	$rc &&= $db->do("ALTER TABLE `version` MODIFY `version` VARCHAR(255) CHARACTER SET utf8");
	$rc &&= $db->do("ALTER TABLE `counters` MODIFY `countername` VARCHAR(255) CHARACTER SET utf8");

	if( !$rc )
	{
		EPrints::abort <<EOW;
An unexpected error occurred while attempting to convert tables to UTF-8.
EOW
	}

	$session->terminate;
}

sub upgrade_mysql_charset_field
{
	my( $colspecs, $session, $db, $dataset, $field ) = @_;

	my $Q_table;
	if( $field->get_property( "multiple" ) )
	{
		$Q_table = $db->quote_identifier($dataset->get_sql_sub_table_name( $field ));
	}
	else
	{
		$Q_table = $db->quote_identifier($dataset->get_sql_table_name);
	}

	$colspecs->{$Q_table} ||= { binary => [], char => [] };

	foreach my $sql ($field->get_sql_type( $session ))
	{
		push @{$colspecs->{$Q_table}->{binary}},
			upgrade_mysql_charset_binary( $db, $Q_table, $sql );
		push @{$colspecs->{$Q_table}->{char}}, $sql;
	}
}

sub upgrade_mysql_charset_ordervalues
{
	my( $colspecs, $session, $db, $dataset, $field, $key_field ) = @_;

	my $sql_field;
	if( $key_field )
	{
		$sql_field = $field;
	}
	else
	{
		$sql_field = EPrints::MetaField->new(
			repository => $session->get_repository,
			name => $field->get_sql_name(),
			type => "longtext",
			allow_null => 1 );
	}

	foreach my $langid ( @{$session->get_repository->get_conf( "languages" )} )
	{
		my $Q_table = $db->quote_identifier($dataset->get_ordervalues_table_name( $langid ));
		$colspecs->{$Q_table} ||= { binary => [], char => [] };

		my $sql = $sql_field->get_sql_type( $session );
		push @{$colspecs->{$Q_table}->{binary}},
			upgrade_mysql_charset_binary( $db, $Q_table, $sql );
		push @{$colspecs->{$Q_table}->{char}}, $sql;
	}
}

sub upgrade_mysql_charset_binary
{
	my( $db, $Q_table, $sql ) = @_;

	my $binary_sql = $sql;
	$binary_sql =~ s/\btext\b/blob/i;
	$binary_sql =~ s/\bvarchar\b/varbinary/i;
	$binary_sql =~ s/\bchar\b/varbinary/i; # otherwise we'll get null padding
	$binary_sql =~ s/\bcharacter set [\w_]+\b//i;
	$binary_sql =~ s/\bcollate [\w_]+\b//i;
	return $binary_sql;
}
