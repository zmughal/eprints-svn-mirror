#!/usr/bin/perl -w -I/opt/eprints/perl_lib

######################################################################
#
#  __COPYRIGHT__
#
# Copyright 2000-2008 University of Southampton. All Rights Reserved.
# 
#  __LICENSE__
#
######################################################################

=pod

=head1 NAME

B<export_hashes> - export the hash values for all documents in an archive.

=head1 SYNOPSIS

B<export_hashes> I<archiveid> [B<options>] [I<filename>]

=head1 DESCRIPTION

Every time a document in eprints is modified a new .xsh file is generated
containing a hash of each file. This script creates a hash of each of these
.xsh files and create a super .xsh file containing each of those hashes.

If no filename is given this script outputs to standard out.

This is an experimental feature.

=head1 ARGUMENTS

=over 8

=item I<archiveid> 

The ID of the EPrint archive to use.

=item I<filename>

A filename to write to. If omited this will write to stdout.

=back

=head1 OPTIONS

=over 8

=item B<--help>

Print a brief help message and exit.

=item B<--man>

Print the full manual page and then exit.

=item B<--quiet>

Be vewwy vewwy quiet. This option will supress all output unless an error occurs.

=item B<--verbose>

Explain in detail what is going on.
May be repeated for greater effect.

=item B<--version>

Output version information and exit.

=item B<--all>

Output hashes of ALL .xsh files for each document, not just the most recent. This takes longer but should be logged periodically.

=back   


__GENERICPOD__

=cut


use Getopt::Long;
use Pod::Usage;
use strict;

use EPrints::Session;
use EPrints::Subject;
use EPrints::ImportXML;

my $xml = 0;
my $version = 0;
my $verbose = 0;
my $quiet = 0;
my $all = 0;
my $purge = 1;
my $help = 0;
my $man = 0;

GetOptions( 
	'help|?' => \$help,
	'man' => \$man,
	'all' => \$all , 
	'version' => \$version,
	'verbose+' => \$verbose,
	'silent' => \$quiet,
	'quiet' => \$quiet
) || pod2usage( 2 );
EPrints::Utils::cmd_version( "reindex" ) if $version;
pod2usage( 1 ) if $help;
pod2usage( -exitstatus => 0, -verbose => 2 ) if $man;
pod2usage( 2 ) if( scalar @ARGV != 2 && @ARGV != 1 );

my $noise = 1;
$noise = 0 if( $quiet );
$noise = 1+$verbose if( $verbose );

# Set STDOUT to auto flush (without needing a \n)
$|=1;

my $session = new EPrints::Session( 1, $ARGV[0], $noise );
exit( 1 ) unless defined $session;

my $ds = $session->get_archive()->get_dataset( "document" );
my $info = { files=>[], all=>$all };
$ds->map( $session, \&show_hash, $info );

my $filename;
if( EPrints::Utils::is_set( $ARGV[1] ) )
{
	$filename = $ARGV[1];
}

EPrints::Probity::create_log(
		$session,
		$info->{files}, 
		$filename );

$session->terminate();
exit;

sub show_hash
{
	my( $session, $dataset, $doc, $info ) = @_;

	my $id = $doc->get_id;
	my $eprint = $doc->get_eprint;
	if( !defined $eprint )
	{
		$session->get_archive->log( "No eprint for document: $id" );
		return;
	}
	my $path = $eprint->local_path;

 	opendir CDIR, $path or return;
	my @filesread = readdir CDIR;
	closedir CDIR;

	my $latest;

	my $file;
	foreach( sort @filesread )
	{
		if( $_ =~ m/^$id\.(.*).xsh$/ )
		{
			my $filename = $path."/".$_;
			if( $info->{all} )
			{
				push @{$info->{files}}, $filename;
			}
			$latest = $filename;
		}
	}

	unless( $info->{all} )
	{
		push @{$info->{files}}, $latest;
	}

}
