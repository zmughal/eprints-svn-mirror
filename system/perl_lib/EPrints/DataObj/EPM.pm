=pod

=for Pod2Wiki

=head1 NAME

B<EPrints::DataObj::EPM> - Class representing an EPrints Package

=head1 DESCRIPTION

=head1 SYSTEM METADATA

=over 4

=back

=head1 METHODS

=over 4

=cut

######################################################################
#
# INSTANCE VARIABLES:
#
#  From EPrints::DataObj
#
######################################################################

package EPrints::DataObj::EPM;

@ISA = ( 'EPrints::DataObj' );

use strict;

######################################################################
=pod

=item $metadata = EPrints::DataObj::EPM->get_system_field_info

Return an array describing the system metadata of the EPrint dataset.

=cut
######################################################################

sub get_system_field_info
{
	my( $class ) = @_;

	return ( 
	
	{ name=>"eprintid", type=>"counter", required=>1, import=>0, can_clone=>0,
		sql_counter=>"eprintid" },

	{ name=>"documents", type=>"subobject", datasetid=>'document',
		multiple=>1 },

	{ name=>"files", type=>"subobject", datasetid=>"file",
		multiple=>1 },

	{ name=>"title", type=>"text" },
	{ name=>"link", type=>"text" },
	{ name=>"date", type=>"text" },
	{ name=>"package_name", type=>"text" },
	{ name=>"package_version", type=>"text" },
	{ name=>"abstract", type=>"text" },
	
	{ name=>"relation", type=>"compound", multiple=>1,
		fields => [
			{
				sub_name => "type",
				type => "text",
			},
			{
				sub_name => "uri",
				type => "text",
			},
		],
	},

	);
}

sub get_dataset_id
{
	return "epm";
}

# mostly for errors generated by us
sub html_phrase
{
	my( $self, $phraseid, @pins ) = @_;

	return $self->repository->html_phrase( "epm:$phraseid", @pins );
}

# convert epdata to objects in documents/documents.files
sub _upgrade
{
	my( $self ) = @_;

	my $repo = $self->repository;

	my $document_dataset = $repo->dataset( "document" );
	my $file_dataset = $repo->dataset( "file" );

	foreach my $doc (@{$self->value( "documents" )})
	{
		if( !UNIVERSAL::isa( $doc, "EPrints::DataObj" ) )
		{
			$doc = $document_dataset->make_dataobj( $doc );
		}
		foreach my $file (@{$doc->value( "files" )})
		{
			if( !UNIVERSAL::isa( $file, "EPrints::DataObj" ) )
			{
				my $content = delete $file->{_content};
				sysread($content,my $data,-s $content);
				$file = $file_dataset->make_dataobj( $file );
				$file->set_value( "data",
					MIME::Base64::encode_base64( $data )
				);
			}
		}
	}
}

=item EPrints::DataObj::EPM->map( $repo, sub { ... }, $ctx )

Apply a function over all installed EPMs.

	sub {
		my( $repo, $dataset, $epm [, $ctx ] ) = @_;
	}

This loads the EPM index files only.

=cut

sub map
{
	my( $class, $repo, $f, $ctx ) = @_;

	my $dataset = $repo->dataset( "epm" );

	my $epm_dir = $repo->config( "base_path" ) . "/lib/epm";
	opendir(my $dh, $epm_dir) or return;
	while(defined(my $file = readdir($dh)))
	{
		next if $file =~ /^\./;
		next if $file !~ /\.epmi$/;
		if(open(my $fh, "<", "$epm_dir/$file"))
		{
			sysread($fh, my $xml, -s $fh);
			close($fh);
			&$f( $repo, $dataset, $class->new_from_xml( $repo, $xml ), $ctx );
		}
	}
	closedir($dh);
}

=item $epm = EPrints::DataObj::EPM->new_from_name( $repo, $name )

Returns a new object representing the installed package $name.

=cut

sub new_from_name
{
	my( $class, $repo, $name ) = @_;

	my $filepath = $repo->config( "base_path" ) . "/lib/epm/$name.epm";
	if( open(my $fh, "<", $filepath) )
	{
		sysread($fh, my $xml, -s $fh);
		close($fh);
		return $class->new_from_xml( $repo, $xml );
	}

	return;
}

sub new_from_xml
{
	my( $class, $repo, $xml ) = @_;

	my $doc = $repo->xml->parse_string( $xml );

	my $epdata = $repo->dataset( "epm" )->dataobj_class->xml_to_epdata(
		$repo, $doc->documentElement
	);

	my $epm = $repo->dataset( "epm" )->make_dataobj( $epdata );
	$epm->_upgrade;

	return $epm;
}

=item $epm = EPrint::DataObj::EPM->new_from_manifest( $repo, $epdata [, @manifest ] )

Makes and returns a new EPM object based on a manifest of installable files.

=cut

sub new_from_manifest
{
	my( $class, $repo, $epdata, @manifest ) = @_;

	my $self = $class->SUPER::new_from_data( $repo, $epdata );

	my $install = $repo->dataset( "document" )->make_dataobj({
		content => "install",
		files => [],
	});
	$self->set_value( "documents", [ $install ]);

	for(@manifest)
	{
		use bytes;
		open(my $fh, "<", $_) or die "Error opening $_: $!";
		sysread($fh, my $data, -s $fh);
		close($fh);
		my $md5 = Digest::MD5::md5_hex( $data );

		$install->set_value( "files", [
			@{$install->value( "files")},
			$repo->dataset( "file" )->make_dataobj({
				filename => $_,
				filesize => length($data),
				data => MIME::Base64::encode_base64( $data ),
				hash => $md5,
				hash_type => "MD5",
			})
		]);

		if( m#^lib/static/images/epm/# )
		{
			my $icon = $repo->dataset( "document" )->make_dataobj({
				content => "icon",
				files => [],
			});
			$icon->set_value( "files", [
				$repo->dataset( "file" )->make_dataobj({
					filename => $_,
					filesize => length($data),
					data => MIME::Base64::encode_base64( $data ),
					hash => $md5,
					hash_type => "MD5",
				})
			]);
			$self->set_value( "documents", [
				@{$self->value( "documents" )},
				$icon,
			]);
		}
	}

	return $self;
}

=item $bool = $epm->is_enabled

Returns true if the $epm is enabled for the current repository.

=cut

sub is_enabled
{
	my( $self ) = @_;

	return -f $self->_cfg_d_file;
}

=item $filename = $epm->filename

Filename to use for this package.

=cut

sub filename
{
	my( $self ) = @_;

	return $self->value( "package_name" );
}

=item $dir = $epm->epm_dir

Path to lib/epm.

=cut

sub epm_dir
{
	my( $self ) = @_;

	return $self->repository->config( "base_path" ) . "/lib/epm";
}

=item @files = $epm->installed_files()

Returns a list of installed files as L<EPrints::DataObj::File>.

=cut

sub installed_files
{
	my( $self ) = @_;

	my $install;
	for(@{$self->value( "documents" )})
	{
		$install = $_ if $_->value( "content" ) eq "install";
	}
	return () if !defined $install;

	return @{$install->value( "files" )};
}

=item $xml = $epm->serialise( [ FILES ] )

Returns the XML serialisation of $epm. If FILES is true files are included.

=cut

sub serialise
{
	my( $self, $files ) = @_;

	local $self->{data}->{documents} = [] if !$files;

	return "<?xml version='1.0'?>\n".$self->repository->xml->to_string(
		$self->to_xml,
		indent => 1
	);
}

=item $ok = $epm->install( HANDLER [, FORCE ] )

Install the EPM into the system. HANDLER is a L<EPrints::CLIProcessor> or
L<EPrints::ScreenProcessor>, used for reporting errors.

=cut

sub install
{
	my( $self, $handler, $force ) = @_;

	my $repo = $self->repository;

	$self->_upgrade;

	my @files = $self->installed_files;
	if( !@files )
	{
		$handler->add_message( "error", $self->html_phrase( "no_files" ) );
		return 0;
	}

	my %files;

	for(@files)
	{
		my $filename = $_->value( "filename" );
		if( $filename =~ m#[\/]\.# || $filename !~ m#^lib/# )
		{
			$handler->add_message( "error", $self->html_phrase( "bad_filename",
					filename => $repo->xml->create_text_node( $filename ),
				) );
			return 0;
		}
		my $data = MIME::Base64::decode_base64( $_->value( "data" ) );
		my $md5 = Digest::MD5::md5_hex( $data );
		if( $md5 ne $_->value( "hash" ) )
		{
			$handler->add_message( "error", $self->html_phrase( "bad_checksum",
					filename => $repo->xml->create_text_node( $filename ),
				) );
			return 0;
		}
		$filename = $repo->config( "base_path" )."/".$filename;
		if( !$force && -e $filename )
		{
			open(my $fh, "<", $filename)
				or die "Error reading from $filename: $!";
			sysread($fh, my $rdata, -s $fh);
			close($fh);
			if( Digest::MD5::md5_hex( $rdata ) ne $md5 )
			{
				$handler->add_message( "error", $self->html_phrase( "file_exists",
						filename => $repo->xml->create_text_node( $filename ),
					) );
				return 0;
			}
		}
		my $directory = $filename;
		$directory =~ s/[^\/]+$//;
		if( !-d $directory && !EPrints->system->mkdir( $directory ) )
		{
			$handler->add_message( "error", $self->html_phrase( "file_error",
					filename => $repo->xml->create_text_node( $directory ),
					error => $repo->xml->create_text_node( $! ),
				) );
			return 0;
		}
		$files{$filename} = $data;
	}

	while(my( $filename, $data ) = each %files)
	{
		my $fh;
		if( !open($fh, ">", $filename) )
		{
			$handler->add_message( "error", $self->html_phrase( "file_error",
					filename => $repo->xml->create_text_node( $filename ),
					error => $repo->xml->create_text_node( $! ),
				) );
			return 0;
		}
		syswrite($fh, $data);
		close($fh);
	}

	EPrints->system->mkdir( $self->epm_dir );

	if( open(my $fh, ">", $self->epm_dir . "/" . $self->filename . ".epm") )
	{
		binmode($fh, ":utf8");
		syswrite($fh, $self->serialise( 1 ));
	}
	if( open(my $fh, ">", $self->epm_dir . "/" . $self->filename . ".epmi") )
	{
		binmode($fh, ":utf8");
		syswrite($fh, $self->serialise( 0 ));
	}

	return 1;
}

=item $ok = $epm->uninstall( HANDLER [, FORCE ] )

Remove the EPM from the system. HANDLER is a L<EPrints::CLIProcessor> or
L<EPrints::ScreenProcessor>, used for reporting errors.

=cut

sub uninstall
{
	my( $self, $handler, $force ) = @_;

	my $repo = $self->repository;

	$self->_upgrade;

	my @files = $self->installed_files;
	if( !@files )
	{
		$handler->add_message( "error", $self->html_phrase( "no_files" ) );
		return 0;
	}

	my %files;

	for(@files)
	{
		my $filename = $_->value( "filename" );
		$filename = $repo->config( "base_path" )."/".$filename;
		next if !-e $filename; # skip missing files
		my $data = "";
		if( open(my $fh, "<", $filename) )
		{
			sysread($fh,$data,-s $fh);
			close($fh);
		}
		if( !$force && Digest::MD5::md5_hex($data) ne $_->value( "hash" ) )
		{
			$handler->add_message( "error", $self->html_phrase( "bad_checksum",
					filename => $repo->xml->create_text_node( $filename ),
				) );
			return 0;
		}
		$files{$filename} = 1;
	}

	foreach my $filename (keys %files)
	{
		if( !unlink($filename) )
		{
			$handler->add_message( "error", $self->html_phrase( "unlink_failed",
					filename => $repo->xml->create_text_node( $filename ),
				) );
		}
	}

	for(qw( .epm .epmi ))
	{
		unlink($self->epm_dir . "/" . $self->filename . $_);
	}

	return 1;
}

sub _cfg_d_file
{
	my( $self ) = @_;

	my $repo = $self->repository;

	return $repo->config( "archiveroot" ) . "/cfg/cfg.d/zz_epm_" . $self->filename . ".pl";
}

=item $ok = $epm->enable( $handler )

Enables the $epm for the current repository.

=cut

sub enable
{
	my( $self, $handler ) = @_;

	my $repo = $self->repository;

	my $sourcepath = $self->epm_dir . "/" . $self->filename . ".pl";
	my $targetpath = $self->_cfg_d_file;

	if( !-f $sourcepath )
	{
		$handler->add_message( "error", $self->html_phrase( "missing_cfg_d",
				filename => $repo->xml->create_text_node( $sourcepath ),
			) );
		return 0;
	}
	if( -f $targetpath )
	{
		$handler->add_message( "error", $self->html_phrase( "file_exists",
				filename => $repo->xml->create_text_node( $targetpath ),
			) );
		return 0;
	}

	my $datasets = $self->current_datasets;

	if(open(my $fh, "<", $sourcepath))
	{
		sysread($fh, my $data, -s $fh);
		close($fh);
		if(open(my $fh, ">", $targetpath))
		{
			syswrite($fh, $data);
			close($fh);
		}
	}

	# reload the configuration
	$repo->load_config;

	$self->update_datasets( $datasets );

	return 1;
}

sub disable
{
	my( $self, $handler ) = @_;

	my $repo = $self->repository;

	my $targetpath = $self->_cfg_d_file;
	return 1 if !-f $targetpath;

	my $datasets = $self->current_datasets;

	unlink( $targetpath );

	# reload the configuration
	$repo->load_config;

	$self->update_datasets( $datasets );

	return 1;
}

=back

=head2 Utility Methods

=over 4

=cut

=item $conf = $epm->current_datasets()

=cut

sub current_datasets
{
	my( $self ) = @_;

	my $repo = $self->repository;

	my $data = {};

	foreach my $datasetid ( $repo->get_sql_dataset_ids() )
	{
		my $dataset = $repo->dataset( $datasetid );
		$data->{$datasetid}->{dataset} = $dataset;
		foreach my $field ($repo->dataset( $datasetid )->fields)
		{
			next if $field->is_virtual;
			$data->{$datasetid}->{fields}->{$field->name} = $field;
		}
	}

	return $data;
}

=item $ok = $epm->update_datasets( $conf )

Update the datasets following any configuration changes made by the extension on being enabled. $conf should be retrieved before enabling by using L</current_datasets>.

=cut

sub update_datasets
{
	my( $self, $before ) = @_;

	my $repo = $self->repository;
	
	my $db = $repo->get_db();

	my $rc = 1;

	# create new datasets/fields tables
	foreach my $datasetid ($repo->get_sql_dataset_ids)
	{
		my $dataset = $repo->dataset( $datasetid );
		if( !exists $before->{$datasetid} )
		{
			$db->create_dataset_tables( $dataset );
		}
		else
		{
			foreach my $field ($dataset->fields)
			{
				next if $field->is_virtual;
				if( !exists $before->{$datasetid}->{fields}->{$field->name} )
				{
					$db->add_field( $dataset, $field );
				}
			}
		}
	}

	# destroy removed datasets/fields tables
	foreach my $datasetid ( keys %$before )
	{
		my $dataset = $before->{$datasetid};
		if( !defined $repo->dataset( $datasetid ) )
		{
			$db->drop_dataset_tables( $dataset );
		}
		else
		{
			foreach my $field (values %{$before->{$datasetid}->{fields}})
			{
				if( !$repo->dataset( $datasetid )->has_field( $field->name ) )
				{
					$db->remove_field( $dataset, $field );
				}
			}
		}
	}
	
	return 1;
}

=head1 COPYRIGHT

=for COPYRIGHT BEGIN

Copyright 2000-2011 University of Southampton.

=for COPYRIGHT END

=for LICENSE BEGIN

This file is part of EPrints L<http://www.eprints.org/>.

EPrints is free software: you can redistribute it and/or modify it
under the terms of the GNU Lesser General Public License as published
by the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

EPrints is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
License for more details.

You should have received a copy of the GNU Lesser General Public
License along with EPrints.  If not, see L<http://www.gnu.org/licenses/>.

=for LICENSE END

