#!/usr/bin/perl -w

######################################################################
#
#  Import CogPrints data into EPrints.
#
######################################################################
#
#  $Id$
#
######################################################################



use EPrints::Session;
use EPrints::MetaInfo;
use EPrints::MetaField;
use EPrints::EPrint;
use EPrints::Database;
use EPrints::Name;
use EPrints::SubjectList;

use Date::Parse;

use strict;


# Context map. Maps old context to new information.
#
#  oldcontext => [ type, published, refereed ] (defaults)


my %contextmap =
(
	"book"     => [ "bookchapter",  "pub",     "FALSE" ],
	"conf"     => [ "confpaper",    "unpub",   "FALSE" ],
	"ibook"    => [ "bookchapter",  "inpress", "FALSE" ],
	"iconf"    => [ "confpaper",    "inpress", "FALSE" ],
	"jour"     => [ "journalp",     "pub",     "FALSE" ],
	"other"    => [ "preprint",     "unpub",   "FALSE" ],
	"pbook"    => [ "bookchapter",  "pub",     "FALSE" ],
	"pconf"    => [ "confpaper",    "pub",     "FALSE" ],
	"pjess"    => [ "journalp",     "inpress", "TRUE"  ],
	"pjour"    => [ "journalp",     "pub",     "TRUE"  ],
	"pnews"    => [ "newsarticle",  "pub",     "FALSE" ],
	"ppost"    => [ "confposter",   "pub",     "FALSE" ],
	"preprint" => [ "preprint",     "unpub",   "FALSE" ],
	"tech"     => [ "techreport",   "pub",     "FALSE" ],
	"uconf"    => [ "confpaper",    "unpub",   "FALSE" ],
	"ujour"    => [ "preprint",     "unpub",   "FALSE" ],
	"upost"    => [ "confposter",   "unpub",   "FALSE" ],
	"urefg"    => [ "preprint",     "unpub",   "FALSE" ],
	"urjnl"    => [ "journalp",     "pub",     "FALSE" ],
	"utech"    => [ "techreport",   "pub",     "FALSE" ]
);

# Maps old IDs -> new IDs
my %idmap;

# Maps new fields -> what needs to be done for them.
#
# Plain "oldfieldname" means put the value of that old field straight into the 
#  new field.
#
# "*" means do nothing, it's been handled (e.g. generated by the system.)
#
# "+" means that the function with the prototype:
#
#     $value = translate_newfieldname( $entry, \@problems )
#
#  should be called to get the value for the new field. e.g. if there's an entry
#  "authors" => "+", the function &translate_authors( $old_value_hash_ref,
#  $problem_array_ref ) will be called to get the new value.

my %translations =
(
	"eprintid"      => "*",
	"username"      => "*",
	"dir"           => "*",
	"datestamp"     => "+",
	"additional"    => "*",
	"reasons"       => "*",
	"subjects"      => "+",
	"type"          => "*",
	"succeeds"      => "*",
	"commentary"    => "+",
	"abstract"      => "abstract",
	"altloc"        => "altloc",
	"authors"       => "+",
	"chapter"       => "chapter",
	"comments"      => "comments",
	"commref"       => "commref",
	"confdates"     => "cdate",
	"conference"    => "conf",
	"confloc"       => "+",
	"department"    => "dept",
	"editors"       => "+",
	"institution"   => "univ",
	"ispublished"   => "+",
	"keywords"      => "keywords",
	"month"         => "+",
	"number"        => "+",
	"pages"         => "+",
	"pubdom"        => "+",
	"publication"   => "pubn",
	"publisher"     => "pubr",
	"refereed"      => "+",
	"referencetext" => "*",
	"reportno"      => "repnum",
	"title"         => "title",
	"volume"        => "volume",
	"year"          => "year"
);


my %ignore_records =
(
	"comp/199802021" => 1,
	"comp/199802022" => 1,
	"neuro/200005001" => 1,
);


my $session = new EPrints::Session( 1 );


# Open error file
open ERROR, ">import_cog_data.errorlog"
	or die "Couldn't create error log: $!\n";

# Open ID map file
open IDMAP, ">import_cog_data.idmap" or die "Couldn't create id map: $!\n";


# Read in the entries and import them

my %entry = ();
my $current_field;

while( <> )
{
	chomp();
	
	if( /^=+$/ )
	{
		# Marker
		if( scalar keys %entry > 0 )
		{
			# Make sure it's not an entry we're supposed to ignore
			unless( $ignore_records{$entry{idcode}} )
			{
				# Do the import, if we've read anything in
				my @errors = &import_eprint( %entry );

				if( $#errors >= 0 )
				{
					# Lob the errors into the error file
					print ERROR "PROBLEM WITH $entry{idcode} ($idmap{$entry{idcode}})\n";
					foreach (@errors)
					{
						print ERROR "$_\n";
					}
				}
			}
		}

		# Clear the current entry stuff
		%entry = ();
		$current_field = undef;
	}
	elsif( /^[\w\-]+:/ )
	{
		# A new field
		/([\w\-\d]+):\s*(.*)$/;

		$current_field = $1;
		if( defined $entry{$1} )
		{
			print ERROR "WARNING: Duplicate field $1\n";
		}
		$entry{$1} = $2;

		#print STDERR "Read >$1< = >$2<\n"; 
	}
	else
	{
		# Add it to the previous field

		if( defined $current_field )
		{
			# Remove beginning spaces
			s/^\s+//;
			# Add it to the current field value (adding a space)
			my $current_val = $entry{$current_field};
			$current_val .= " ".$_;
			$entry{$current_field} = $current_val;
		}
		else
		{
			print ERROR "Strange line: >>$_<<\n==\n";
		}
	}
}


# Now write the id map
foreach( keys %idmap )
{
	print IDMAP "$_:$idmap{$_}\n";
}


# Done !
close( ERROR );
close (IDMAP );



sub import_eprint
{
	my( %entry ) = @_;

	print STDERR "Importing entry: ".(defined $entry{idcode} ? $entry{idcode} : "(no ID code!!!)" )."\n";

	# Hooks in here for special cases
	delete $entry{editors} if( $entry{idcode} eq "neuro/199811004" );
	$entry{format} = "html" if( $entry{idcode} eq "bio/199710002" );
	$entry{date} = "Sat Jun  6 15:41:38 1998"
		if( $entry{idcode} eq "psyc/199806005" );
	$entry{userid} = "chalmers" if( $entry{userid} eq "ChalmersD" );
	$entry{userid} = "kashkin1" if( $entry{userid} eq "kashkin" );
	$entry{userid} = "lgabora" if( $entry{userid} eq "lgabora1" );
	
	my @errors;
	
	# Get the context (pjour, ujour etc.)
	my $context = $entry{context};
	
	if( !defined $context )
	{
		# Default is a preprint
		$context = "preprint";
		#push @errors, "No context!";
		#return( @errors );
	}

	# Get defaults
	my( $type, $ispublished, $refereed ) = @{$contextmap{$context}};
	
	if( !defined $type )
	{
		push @errors, "Unrecognised context: $context";
		return( @errors );
	}
	
	my $userid = $entry{userid};
	if( !defined $userid )
	{
		push @errors, "No user ID!";
		return( @errors );
	}

	# Create the EPrint!
	my $eprint = EPrints::EPrint->create( $session,
	                                      $EPrints::Database::table_archive,
	                                      $userid );

	if( !defined $eprint )
	{
		my $error = $session->{database}->error();
		die "Couldn't create EPrint $entry{idcode}: DB<$error> OTHER<$!>\n";
	}

	$eprint->{type} = $type;
	$eprint->{ispublished} = $ispublished;
	$eprint->{refereed} = $refereed;

	# Put the ID in the map
	$idmap{$entry{idcode}} = $eprint->{eprintid};

	# Get the relevant fields
	my @fields = EPrints::MetaInfo->get_eprint_fields( $type );
	
	my $f;
	
	foreach $f (@fields)
	{
		#print STDERR "Handling field $f->{name}\n";

		my $oldfield = $translations{$f->{name}};
		
		if( !defined $oldfield )
		{
			# Don't know what to do! Help!
			push @errors, "Don't know what to do about $f->{name}";
		}
		elsif( $oldfield eq "+" )
		{
			# Give to relevant translation function
			my $function_name = "translate_$f->{name}";
			{
				no strict 'refs';
				$eprint->{$f->{name}} = &{$function_name}( $eprint, 
				                                           \%entry,
				                                           \@errors );
			}
		}
		elsif( $oldfield ne "*" )
		{
			# Just take the value from the old field
			$eprint->{$f->{name}} = $entry{$oldfield};
		}
	}
	
	#print STDERR "Committing\n";

	# Copy across the files
	&import_document( $session, \%entry, $eprint, \@errors );

	# Fix for Ingber's altloc's
	if( $eprint->{username} eq "IngberL" )
	{
		$eprint->{altloc} =~ s/\.Z/.gz/g;
	}

	# Put in the d/b
	$eprint->commit();

	#print STDERR "Validating\n";

	my @validation_problems;

	# Check for any problems
	my $probs = $eprint->validate_type();
	push @validation_problems, @$probs;

	$probs = $eprint->validate_meta();
	push @validation_problems, @$probs;

	$probs = $eprint->validate_subject();
	push @validation_problems, @$probs;

	EPrintSite::Validate->validate_eprint( $eprint, \@validation_problems );

	if( scalar @validation_problems > 0 )
	{
		# Try downgrading to a preprint.
		$eprint->{type} = "preprint";
		$eprint->prune();
		$eprint->commit();
		
		@validation_problems = ();
		$probs = $eprint->validate_type();
		push @validation_problems, @$probs;

		$probs = $eprint->validate_meta();
		push @validation_problems, @$probs;

		$probs = $eprint->validate_subject();
		push @validation_problems, @$probs;

		EPrintSite::Validate->validate_eprint( $eprint, \@validation_problems );
	}
	
	$probs = $eprint->validate_documents();
	push @validation_problems, @$probs;

	push @errors, @validation_problems;
	

	# Generate static HTML page
	$eprint->generate_static();

	#print STDERR "Import complete\n";

	return( @errors );
}

######################################################################
#
#  Translation functions: all have the prototype
#
# $newvalue = translate_fieldname( $new_eprint,
#                                  $old_value_hash,
#                                  $problem_array_ref )
#
######################################################################

sub translate_datestamp
{
	my( $eprint, $old_values, $problems ) = @_;
	
	#print STDERR "Parsing date: $old_values->{date}\n";

	my( $ss, $mm, $hh, $day, $month, $year, $zone ) = strptime(
		$old_values->{date} );

	while( length $day < 2 )
	{
		$day = "0".$day;
	}

	# strptime() gives months 0-11; convert to range 01-12.
	$month++;
	while( length $month < 2 )
	{
		$month = "0".$month;
	}

	# year is 1900+<as given by strptime()
	$year += 1900;

	return( $year."-".$month."-".$day );
}


sub translate_subjects
{
	my( $eprint, $old_values, $problems ) = @_;

	my $sublist = new EPrints::SubjectList;
	
	# First get the main code
	my $sub = &new_subject( $old_values->{catcode} );
	
	if( !defined $sub )
	{
		push @$problems, "Unknown subject tag: $old_values->{catcode}";
	}
	else
	{
		$sublist->add_tag( $sub );
	}
	
	# Now do the same for each of the cross-posted ones
	if( defined $old_values->{cross} )
	{
		my @cross = split /,\s*/, $old_values->{cross};

		foreach (@cross)
		{
			my $sub = &new_subject( $_ );

			if( !defined $sub )
			{
				push @$problems, "Unknown subject tag: $old_values->{catcode}";
			}
			else
			{
				$sublist->add_tag( $sub );
			}
		}
	}

	return( $sublist->to_string() );
}

sub new_subject
{
	my( $old_subject ) = @_;

#	print STDERR "Old subject = ".(defined $old_subject?$old_subject:"undefined!")."\n";
	
	# Remove the stuff before the .
	$old_subject =~ s/.*\.//;
	
	# Should be OK now, just need to change "neuro" to "neuro-neu"
	$old_subject = "neuro-neu" if( $old_subject eq "neuro" );

#print STDERR "New subject = ".(defined $old_subject?$old_subject:"undefined!")."\n";

	# Veryify the subject is valid
	my $dummy_subject = new EPrints::Subject( $session, $old_subject );

	return( undef ) if( !defined $dummy_subject );
	
	return( $old_subject );
}


sub translate_commentary
{
	my( $eprint, $old_values, $problems ) = @_;

	# Tricky one - might not have the paper being commented on in the map yet.
	if( defined $old_values->{commid} && $old_values->{commid} ne "" &&
		$old_values->{commid} ne "-" )
	{
#		return( "COMMID:".$old_values->{commid} );

		my $commid = $old_values->{commid};

		if( defined $idmap{$commid} )
		{
			# It's OK, we have the new ID
			return( $idmap{$commid} )
		}
		else
		{
			# We're going to have to defer
			return( "COMMIDOLD:$commid" );
		}
	}
	else
	{
		return( undef );
	}
}


sub translate_authors
{
	my( $eprint, $old_values, $problems ) = @_;
	
	return( EPrints::Name->import_names( $old_values->{authors}, "\\+" ) );
}


sub translate_confloc
{
	my( $eprint, $old_values, $problems ) = @_;
	
	return( $old_values->{place} ) if( defined $old_values->{place} );
	return( $old_values->{locn} );
}


sub translate_editors
{
	my( $eprint, $old_values, $problems ) = @_;
	
	my $nameslist = undef;
	
	if( defined( $old_values->{editor} ) )
	{
		$nameslist = EPrints::Name->import_names( $old_values->{editor}, "\\+" );
	}
	elsif( defined( $old_values->{editors} ) )
	{
		$nameslist = EPrints::Name->import_names( $old_values->{editors}, "\\+" );
	}
	
	return( $nameslist );
}


sub translate_ispublished
{
	my( $eprint, $old_values, $problems ) = @_;
	
	# Probably set already, but in some cases will need to look at the
	# "edition" field...
	if( defined $old_values->{edition} )
	{
		return( "unpub" ) if( $old_values->{edition} eq "preprint" );
		return( "pub" ) if( $old_values->{edition} eq "reprint" );
	}
	
	return( $eprint->{ispublished} );
}


sub translate_month
{
	my( $eprint, $old_values, $problems ) = @_;
	
	my $val = $old_values->{month};

	if( !defined $val )
	{
		# Look for pdate
		return( undef ) if( !defined $old_values->{pdate} );
		
		$val = $old_values->{pdate};

		# Remove all digits and other crap
		$val =~ s/[\W]//g;
		$val =~ s/\d//g;
	}

	# Is the old one a number?
	if( $val =~ /^\d+$/ )
	{
		return( undef ) if( $val < 1 || $val > 12 );
		
		my @months =
		( "unspec", "jan", "feb", "mar", "apr", "may", "jun", "jul", "aug", "sep",
		"oct", "nov", "dec" );

		return( $months[$val] );
	}
	else
	{
		# Perhaps it's in text. Try to guess from the first three letters.
		my %months = (
			"jan" => 1,
			"feb" => 1,
			"mar" => 1,
			"apr" => 1,
			"may" => 1,
			"jun" => 1,
			"jul" => 1,
			"aug" => 1,
			"sep" => 1,
			"oct" => 1,
			"nov" => 1,
			"dec" => 1 );
			
		my $firstthree = lc (substr ($val, 0, 3));

		if( defined $months{$firstthree} )
		{
			return( $firstthree );
		}
		else
		{
			return( "unspec" );
		}		
	}
}


sub translate_number
{
	my( $eprint, $old_values, $problems ) = @_;
	
	return( $old_values->{issue} ) if( defined $old_values->{issue} );
	
	return( $old_values->{number} );
}


sub translate_pages
{
	my( $eprint, $old_values, $problems ) = @_;
	
	my @pagevals;
	
	if( defined $old_values->{pages} && $old_values->{pages} ne "" )
	{
		# Form "pages: xxx-yyy"
		@pagevals = split /-/, $old_values->{pages};
	}
	elsif( defined $old_values->{pages1} && $old_values->{pages1} ne "" )
	{
		# Form "pages1: xxx   pages2: yyy"
		$pagevals[0] = $old_values->{pages1};
		$pagevals[1] = $old_values->{pages2} if( defined $old_values->{pages2} &&
		                                         $old_values->{pages2} ne "" );
	}
	else
	{
		# No page numbers at all
		return( undef );
	}
	
	if( $#pagevals == 1 )
	{
		# It's page-page

		# Return just the one if "from" and "to" are the same
		return( $pagevals[0] ) if( $pagevals[0] eq $pagevals[1] );
		
		# Otherwise return as a range
		return( $pagevals[0]."-".$pagevals[1] );
	}
	else
	{
		# Return as-is, single page
		return( $old_values->{pages} );
	}
}


sub translate_pubdom
{
	my( $eprint, $old_values, $problems ) = @_;

	return( "TRUE" ) if( defined $old_values->{owner} && 
	                     $old_values->{owner} eq "thdpubdom" );

	return( "FALSE" );
}


sub translate_refereed
{
	my( $eprint, $old_values, $problems ) = @_;
	
	my $ref = $old_values->{refereed};
	
	return( "TRUE" ) if( defined $ref && $ref eq "yes" );

	return( "FALSE" ) if( defined $ref && ( $ref eq "no" || $ref eq "on" ) );
	
	return( $eprint->{refereed} );
}



######################################################################
#
# import_document( $session, $old_record, $eprint, $errors )
#
#  Copies the documents across from $old_record to $eprint. Errors in
#  $errors (array ref.)
#
######################################################################

sub import_document
{
	my( $session, $old_record, $eprint, $errors ) = @_;
	
	my $path = $old_record->{idcode};
	my( $archive, $yearmonth, $number ) = ($path =~ m/(.+)\/(\d\d\d\d\d\d)(\d\d\d)/);

	$path = "data/archives/$archive/papers/$yearmonth/";

	# This maps fields in the old record to a tuple:
	#   [ directory in old record, new format descriptor, need unzip ]
	my %newform = (
		"file-html-main"   => [ "doc.html", "HTML", 0 ],
		"file-ps-main"     => [ "doc.ps", "PS", 0 ],
		"file-psgz-main"   => [ "doc.psgz", "PS", 1 ],
		"file-pdf-main"    => [ "doc.pdf", "PDF", 0 ],
		"file-pdfgz-main"  => [ "doc.pdfgz", "PDF", 1 ],
		"file-txt-main"    => [ "doc.txt", "ASCII", 0 ]
	);
	
	# Similar form, but maps format: values to dir, new format, need unzip tuple
	my %oldform = (
		"html"  => [ "doc.html", "HTML", 0 ],
		"ps"    => [ "doc.ps", "PS", 0 ],
		"ps.gz" => [ "doc.psgz", "PS", 1 ],
		"txt"   => [ "doc.txt", "ASCII", 0 ] );

	my $have_new_form = 0;

	foreach (keys %newform)
	{
		if( defined $old_record->{$_} && $old_record->{$_} ne "" )
		{
			$have_new_form = 1;
			my $format_info = $newform{$_};
			my $new_format = $format_info->[1];
			my $compressed = $format_info->[2];

			# Hooks for duff entries
			if( $old_record->{idcode} eq "phil/200004001" )
			{
				$new_format = "HTML";
				$compressed = 0;
			}
			
			&copy_files( $session,
			             $eprint,
			             $new_format,
			             $path.$yearmonth.$number."/".$format_info->[0]."/",
			             $old_record->{$_},
							 1,
			             $compressed,
			             $errors );
		}
	}
	
	if( defined $old_record->{format} && $have_new_form==0 )
	{
		foreach (keys %oldform)
		{
			if( $old_record->{format} eq $_ )
			{
				my $format_info = $oldform{$old_record->{format}};
				my( $file, $dir, $copy_all );

				# See if there's an id.format file...
				if( -e $path.$yearmonth.$number.".".$_ )
				{
					# OK, this is the file
					$file = $yearmonth.$number.".".$_;
					$dir = $path;
					$copy_all = 0;
				}
				elsif( -e $path.$yearmonth.$number.".".$_.".gz" )
				{
					# There's a gzipped, id.format file
					$file = $yearmonth.$number.".".$_.".gz";
					$dir = $path;
					$format_info->[2] = 1;
					$copy_all = 0;
				}
				else					
				{
					# The files must be in a directory.
					$dir = $path.$yearmonth.$number."/";
					$copy_all = 1;
					
					# Work out the main file
					if( defined $old_record->{file0} )
					{
						if( -e $dir.$old_record->{file0} )
						{
							# The file is still called what file0 is called
							$file = $old_record->{file0};
						}
						else
						{
							# Probably called number.format
							$file = $yearmonth.$number.".".$_;
						}
					}
					else
					{
						push @$errors, "Can't find main file for format $_, old record id $old_record->{idcode}";
						return;
					}
				}

				# Copy 'em across.
				&copy_files( $session,
				             $eprint,
				             $format_info->[1],
				             $dir,
				             $file,
								 $copy_all,
				             $format_info->[2],
								 $errors );
			}
		}
	}
	
	return;
}


######################################################################
#
# copy_files( $session,
#             $eprint,
#             $format,
#             $from_dir,
#             $main_file,
#             $copy_whole_dir,
#             $compressed,
#             $errors )
#
#  Creates a suitable document object for the given eprint, and transfers
#  files from the directory $from_dir to it.
#
######################################################################

sub copy_files
{
	my( $session, $eprint, $format, $from_dir, $main_file, 
		$copy_whole_dir, $compressed, $errors ) = @_;
		
	my $doc = EPrints::Document->create( $session, $eprint, $format );
	
	unless( defined $doc )
	{
		push @$errors,
			"Couldn't make document entry for eprint $eprint->{eprintid} format $format";
		
		return;
	}
	
	if( $compressed )
	{
		# Have to uncompress. Assume just one file.

		# Remove the .gz
		my $dest_file = $main_file;
		$dest_file =~ s/.[Gg][Zz]$//;

		open IN, "gunzip -c <$from_dir$main_file|";
		$doc->upload( \*IN, $dest_file );
		close( IN );
		$doc->set_main( $dest_file );
		$doc->commit();
	}
	elsif( $copy_whole_dir )
	{
		my $dest_dir = $doc->local_path();
		#print STDERR "cp -a $from_dir* $dest_dir\n";
		my $rc = 0xffff & system( "cp -a $from_dir* $dest_dir" );
		if( $rc )
		{
			push @$errors, "Couldn't copy files for $eprint->{eprintid} format $format: $!";
			$doc->remove();
			return;
		}
		$doc->set_main( $main_file );
		$doc->commit();
	}
	else
	{
		# Just copy the one file
		open IN, $from_dir.$main_file;
		$doc->upload( \*IN, $main_file );
		close( IN );
		$doc->set_main( $main_file );
		$doc->commit();
	}
}
