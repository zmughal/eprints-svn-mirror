#!/usr/bin/perl -w -I/usr/share/eprints3/perl_lib

use strict;

use File::Path;
use EPrints;
use File::Copy;
use Digest::MD5;

if(!defined $ARGV[0] || !defined $ARGV[1])
{
       print "\nUsage is:";
       print "\n\tinstall_app repository_id [install|uninstall] [app_name|app_path] [--force]\n\n";
       exit(1);
}

my $repository = new EPrints::Session( 1, $ARGV[0] ) or die("cant create Session object");

my $operation = $ARGV[1];

my $local_file_path = $ARGV[2];

my $force = 0;

if (defined $ARGV[3]) {
	if ( "$ARGV[3]" eq "--force" ) {

		$force = 1;

	}
}
my $ret = "";
if ( $operation eq "install") {
	
	$ret = install($repository,$local_file_path,$force);

} elsif ($operation eq "remove" ) {
	
	$ret = remove($repository,$local_file_path,$force);

} elsif ($operation eq "backup" ) {
	
	$ret = make_backup($repository, $local_file_path);

} elsif ($operation eq "get_version") {
	
	$ret = get_package_version($repository, $local_file_path);

} elsif ($operation eq "check_md5") {
	
	$ret = check_required_md5($repository, $local_file_path, "/tmp/A0j3aI2qDT", "/home/dct05r/eprints/archives/upping/cfg/plugins/EPrints/Plugin/Screen/Admin/TestScreen.pm");
}

print $ret . "\n";

sub unpack_package 
{
	my ($repository, $app_path, $directory) = @_;
	
	my $mime_type = $repository->call('guess_doc_type',$repository ,$app_path );

	my $type;

	if ($mime_type eq "application/zip") {
		$type = "zip";
	} else {
		$type = "targz";
	}

	
	my $rc = $repository->get_repository->exec(
			$type,
			DIR => $directory,
			ARC => $app_path );

	return $rc;

}

sub install 
{
	my ($repository, $app_path, $force) = @_;

	my $directory;

	my $rc = 1;

	if ( -d $app_path ) {
		$directory = $app_path;
	} else {
		$directory = File::Temp->newdir( CLEANUP => 1 );
		my $rc = unpack_package($repository, $app_path, $directory);
		if ($rc) {
			return "failed to unpack package";
		}
	}

	my $message;
	
	my $archive_root = $repository->get_repository->get_conf("archiveroot");
	my $epm_path = $archive_root . "/var/epm/packages/";

	if ( !-d $epm_path ) {
		mkpath($epm_path);
	}
        
	if( !-d $epm_path )
        {
                return "Failed to create package management cache";
        }

	my $package_name;
	my $package_path;
	my $file_md5s;
	my $backup_directory;
	my $abort = 0;

        File::Find::find( {
                no_chdir => 1,
                wanted => sub {
                        return unless $rc and !-d $File::Find::name;
                        my $filepath = $File::Find::name;
                        my $filename = substr($filepath, length($directory));
                        open(my $filehandle, "<", $filepath);
                        unless( defined( $filehandle ) )
                        {
                                $rc = 0;
                                return;
                        }
			if ( (substr $filename, -5) eq ".spec" ) {
				$package_name = substr $filename, 0, -5;
				$package_path = $epm_path . "/" . $package_name;
				my $spec_file = $package_path . "/" . $filename;

				# CHECK EXISTS!
				if ( -e $spec_file and $force < 1) {
				
					my $installed_version = get_package_version($repository, $spec_file);
					my $this_version = get_package_version($repository, $filepath);
				
					if ($this_version lt $installed_version) {
						$message = "Package is already installed, use --force to override";	
						$abort = 1;
						return;
					}
			
					$backup_directory = make_backup($repository, $package_name);
						
				}
				mkpath($package_path);

				copy($filepath, $spec_file);

			} else {
				my $path_separator = '/';
			 	$filepath =~ m/[^\Q$path_separator\E]*$/;
				my $required_dir = substr ($`, length($directory));
				my $required_path = $archive_root . "/" . $required_dir;

				mkpath($required_path);
				
				my $installed_path = $archive_root . $filename;
				my $config_file = 0;

				if ( ( substr $filename. 0, 9 ) eq "cfg/cfg.d" ) {
					$config_file = 1;
				}

				if ( -e $installed_path and $force < 1) {
					my $installed_md5 = md5sum($installed_path);
					my $this_md5 = md5sum($filepath);
					my $package_managed = 1;
					if ( defined $backup_directory ) {
						$package_managed = check_required_md5($repository,$package_name,$backup_directory,$installed_path);
					}
					if ($package_managed < 1 and $config_file < 1) {
						write_md5s($repository,$package_path,$file_md5s); 
						remove($repository, $package_name, 1);
						if ( defined $backup_directory) {
							install($repository, $backup_directory, 1);
						}
						$message = "Install Failed: $installed_path has been changed outside the package manager, use --force to override";
						$abort = 1;
						return;
					} elsif ($package_managed < 1 and $config_file) {
						$message = "Config file has changed, not installing use --force to override";
					} 
				}
					
				copy($filepath, $installed_path);

				if ( !-e $installed_path ) {
					write_md5s($repository,$package_path,$file_md5s); 
					remove($repository, $package_name, 1);
					if ( defined $backup_directory) {
						install($repository, $backup_directory, 1);
					}
					$message = "Failed to install $filepath, installation aborted and reverted";
					$abort = 1;
					return;
				} else {
					my $md5 = "-";
					if ( ( substr $filename. 0, 9 ) eq "cfg/cfg.d" ) {
					} else {
						$md5 = md5sum($filepath);
					}
					$file_md5s .= $installed_path . " " . $md5 . "\n"
				}
			}
                },
        }, "$directory" );
	if ($abort > 0) {
		return $message;
	}

	write_md5s($repository,$package_path,$file_md5s); 
	
	if (!defined $message) {

		$message = "Package Successfully Installed";
	
	} 

	return $message;

}

sub get_package_version
{
	my ($repository, $spec_file) = @_;

	my $version = 100;

	open (SPECFILE, $spec_file);
	while (<SPECFILE>) {
		chomp;
		my @bits = split(":",$_);
		my $key = $bits[0];
		my $value = trim($bits[1]);
		if ($key eq "version") {
			$version = $value;
		}
	}
	close (SPECFILE);
	
	return $version;

}

sub trim 
{
	my ($string) = @_;	
	$string =~ s/^\s+//;
	$string =~ s/\s+$//;
	return $string;

}

sub check_required_md5
{
	my ( $repository, $package_name, $backup_dir, $installed_path ) = @_;

	my $md5_file = $backup_dir . "/checksums";
	
	my $archive_root = $repository->get_repository->get_conf("archiveroot");
	my $path_to_file = substr($installed_path, length($archive_root));

	open (MD5FILE, $md5_file);
	while (<MD5FILE>) {
		chomp;
		my @bits = split(/ /,$_);
		my $file = $bits[0];
		my $md5 = $bits[1];
		$file =~ s/$archive_root//;
		if ($file eq $path_to_file){
			my $installed_md5 = md5sum($installed_path);
			if ($installed_md5 eq $md5) {
				return 1;
			}
		}
	}
	close (MD5FILE);
	
	return 0;

} 

sub write_md5s 
{
	my ( $repository, $package_path, $file_md5s ) = @_;

	if ( defined $file_md5s) {
		my $md5_file = $package_path . "/checksums";
		open (MD5FILE, ">$md5_file");
		print MD5FILE $file_md5s;	
	}
}


sub make_backup 
{
	my ($repository, $package_name) = @_;
	
	my $backup_directory = File::Temp->newdir( CLEANUP => 1 );

	my $archive_root = $repository->get_repository->get_conf("archiveroot");
	my $epm_path = $archive_root . "/var/epm/packages/";
	my $package_path = $epm_path . "/" . $package_name;
	
	my $spec_file = $package_path . "/" . $package_name . ".spec";
	my $md5_file = $package_path . "/checksums";

	copy($package_path . "/" . $package_name . ".spec", $backup_directory . "/" . $package_name . ".spec");
	copy($package_path . "/checksums", $backup_directory . "/checksums");

	open (MD5FILE, $md5_file);
	while (<MD5FILE>) {
		chomp;
		my @bits = split(/ /,$_);
		my $file = $bits[0];
		my $md5 = $bits[1];
		
		my $path_separator = '/';
		$file =~ m/[^\Q$path_separator\E]*$/;
		my $required_dir = substr ($`, length($archive_root));
		my $required_path = $backup_directory . "/" . $required_dir;
		mkpath($required_path);
		my $file_sub = substr($file, length($archive_root));

		if ( -e $file ) {
			copy($file,$backup_directory . "/" . $file_sub);
		}
	}
	close (MD5FILE);
	return $backup_directory;
}


sub remove
{
	my ($repository, $package_name, $force) = @_;
	
	my $archive_root = $repository->get_repository->get_conf("archiveroot");
	my $epm_path = $archive_root . "/var/epm/packages/";
	my $package_path = $epm_path . "/" . $package_name;
	
	my $spec_file = $package_path . "/" . $package_name . ".spec";
	my $md5_file = $package_path . "/checksums";

	if ( !-e $spec_file or !-e $md5_file and $force < 1) {
                
		return "Cannot locate installed package : " . $package_name;
		
	}
	

	my $pass = 1;
	my @files;

	open (MD5FILE, $md5_file);
	while (<MD5FILE>) {
		chomp;
		my @bits = split(/ /,$_);
		my $file = $bits[0];
		my $md5 = $bits[1];

		push @files, $file;
		if ( -e $file ) {
			my $re_check = md5sum($file);
			if (!($re_check eq $md5)) {
				$pass = 0;
			}
		}
	}
	close (MD5FILE);

	if ($pass != 1 and $force != 1 ) {
	
                return "Warning: Package has changed since install! Use --force to override";

	}  
	
	my $backup_directory = make_backup($repository, $package_name);

	my $rc = 0;
	my $failed_flag = 0;

	foreach my $file (@files) {
		if ( -e $file ) {
			$rc = unlink $file;
			if ($rc != 1) {
				$failed_flag = 1;
			}
		}
	}

	if ($failed_flag != 0) {
		
		install($repository, $backup_directory, 1);

		return "Warning: Failed to remove package! Use --force to override";
			
	}
	
	rmtree($package_path);

	return "Package Successfully Removed";
	

}

sub md5sum
{
	my $file = shift;
	my $digest = "";
	eval{
		open(FILE, $file) or die "Can't find file $file\n";
		my $ctx = Digest::MD5->new;
		$ctx->addfile(*FILE);
		$digest = $ctx->hexdigest;
		close(FILE);
	};
	if($@){
		print $@;
		return "";
	}
	return $digest;
}

1;
